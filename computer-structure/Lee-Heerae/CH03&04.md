# ch03

## 명령어

- 모든 소스 코드는 컴퓨터 내부에서 명령어로 변환됨
- 고급언어
    - 컴퓨터가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어
    - 대부분의 프로그래밍 언어
- 저급 언어
    - 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    - 명령어로 이루어져 있음
    - 종류
        - 기계어
            - 0과 1의 명령어 비트로 이루어진 언어
        - 어셈블리어
            - 0과 1로 표현된 명령어를 읽기 편한 형태로 번역한 언어

## 컴파일 언어와 인터프리터 언어

- 고급 언어가 저급 언어로 변환되는 방식
- 컴파일 언어
    - 컴파일 방식으로 작동하는 프로그래밍 언어
    - 컴파일 : 코드 전체가 저급 언어로 변환되는 과정
    - 컴파일러 : 컴파일을 수행해주는 도구
    - 컴파일러가 소스 코드 내에서 오류를 하나라도 발견하면 컴파일에 실패함
    - 목적 코드 : 컴파일러를 통해 저급 언어로 변환된 코드
- 인터프리터 언어
    - 인터프리터 방식으로 작동하는 프로그래밍 언어
    - 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
    - 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음

## 목적파일 vs 실행파일

- 목적 파일
    - 목적 코드로 이루어진 파일
    - 목적 코드가 실행파일이 되기 위해서는 링킹이라는 작업이 필요
- 실행 파일
    - 실행 코드로 이루어진 파일

## 연산코드와 오퍼랜드

- 명령어는 연산코드와 오퍼랜드로 구성되어 있음
- 연산 코드 : 명령어가 수행할 연산
- 오퍼랜드 : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치

## 오퍼랜드

- 연산에 사용할 데이터가 저장된 위치 즉, 메모리 주소나 레지스터 이름이 담김
- 오퍼랜드 필드 == 주소필드
    - 오퍼랜드 개수가 n이라고 할 떄 해당 명령어를 n-주소 명령어라고 함

## 연산 코드

- 가장 기본적인 연산 코드 유형
    1. 데이터 전송
        - MOVE : 데이터 이동
        - STORE : 메모리 저장
        - LOAD (FETCH) : 메모리에서 cpu로 데이터 이동
        - PUSH : 스택에 데이터 저장
        - POP : 스택의 최상단 데이터 꺼내기
    2. 산술/논리 연산
        - ADD / SUBTRACT / MULTIPLY / DIVIDE : 산술연산 수행
        - INCREMENT / DECREMENT : +-1
        - AND / OR / NOT : 논리 연산 수행
        - COMPARE : 비교
    3. 제어 흐름 변경
        - JUMP
        - CONDITIONAL JUMP
        - HALT
        - CALL
        - RETURN
    4. 입출력 제어
        - READ (INPUT)
        - WRITE (OUTPUT)
        - START IO
        - TEST IO
    
    ## 주소 지정 방식
    
    - 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
    - 유효 주소 : 연산의 대상이 되는 데이터가 저장된 위치
    - 대표적인 주소 지정 방식
        - 즉시 주소 지정 방식
            - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
            - 가장 간단한 형태의 주소 지정 방식
            - 다른 방식들보다 빠름
        - 직접 주소 지정 방식
            - 오퍼랜드 필드에 유효 주소를 직접적으로 명시
        - 간접 주소 지정 방식
            - 유효 주소의 주소를 오퍼랜드 필드에 명시
            - 일반적으로 느린 방식
        - 레지스터 주소 지정 방식
            - 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
            - 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음
        - 레지스터 간접 주소 지정 방식
            - 연산에 사용할 데이터를 메모리에 저장하고 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
            - 간접 주소 지정 방식보다 빠름

# CH04

## ALU

- 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들임
- 플래그
    - 연산 결과에 대한 추가적인 상태 정보
    - CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 일종의 참고 정보
    - 플래그 레지스터에 저장됨
- 대표 플래그
    - 부호 플래그
    - 제로 플래그
    - 캐리 플래그
    - 오버플로우 플래그
    - 인터럽트 플래그
    - 슈퍼바이저 플래그

## 제어 장치

- 제어 신호를 내보내고, 명령어를 해석하는 부품
- CPU의 구성 요소 중 가장 정교하게 설계된 부품
- 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
- 제어 장치가 받아들이는 정보
    1. 클럭 신호를 받아들임
        - 클럭 : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
    2. 해석해야 할 명령어를 받아들임
    3. 플래그 레지스터 속 플래그 값을 받아들임
    4. 시스템 버스, 그 중에서 제어 버스로 전달된 제어 신호를 받아들임
- 제어장치가 내보내는 정보
    - CPU 외부에 전달하는 제어 신호
        - 제어 버스롤 제어 신호를 내보냄
        - 메모리에 전달하는 제어신호
        - 입출력장치에 전달하는 제어신호
    - CPU 내부에 전달하는 제어 신호
        - ALU에 전달하는 제어 신호 - 수행할 연산을 지시하기 위해
        - 레지스터에 전달하는 제어 신호 - 데이터 이동이나 저장된 명령어를 해석하기 위해

## 반드시 알아야 할 레지스터

1. 프로그램 카운터
    - 메모리에 가져올 명령어의 주소, 즐 메모리에서 읽어 들일 명령어의 주소를 저장
    - 명령어 포인터라고도 부름
2. 명령어 레지스터
    - 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장
3. 메모리 주소 레지스터
    - 메모리의 주소를 저장하는 레지스터
4. 메모리 버퍼 레지스터
    - 메모리와 주고받을 값을 저장하는 레지스터
    - 메모리 데이터 레지스터라고도 불림
5. 플래그 레지스터
    - 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터
6. 범용 레지스터
    - 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
7. 스택 포인터
    - 스택 주소 지정 방식이라는 주소 지정 방식에 사용됨
    - 스택의 꼭대기를 가리키는 레지스터 → 마지막으로 저장한 값의 위치를 저장하는 레지스터
8. 베이스 레지스터
    - 변위 주소 지정 방식이라는 주소 지정 방식에 사용됨

## 특정 레지스터를 이용한 주소 지정 방식

1. 스택 주소 지정 방식
    - 스택과 스택 포인터를 이용한 주소 지정 방식
    - 스택은 메모리 안에 스택 영역을 사용
        - 스택 영역 : 스택 처럼 사용하기로 암묵적으로 약속된 영역
2. 변위 주소 지정 방식
    - 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
    - 명령어 구조
        - 연산 코드 필드
        - 레지스터 필드
        - 오퍼랜드 필드
    - 종류
        - 상대 주소 지정 방식
            - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
            - 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용
        - 베이스 레지스터 주소 지정 방식
            - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
            - 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식

## 명령어 사이클과 인터럽트

- 명령어 사이클
    - 하나의 명령어를 처리하는 정형화된 흐름
    - 각각의 명령어들이 반복되며 실행되는 일정한 주기
    - 명령어 사이클 과정
        1. 인출 사이클 : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
        2. 실행 사이클 : CPU로 가져온 명령어를 실행하는 단계
        
        ++ 메모리 접근이 더 필요한 경우 간접 사이클 수행
        
- 인터럽트
    - 정해진 흐름에 따라 명령어를 처리하다 이 흐름이 끊어지는 상황
    - CPU 작업을 방해하는 신호
    - 인터럽트 종류
        - 동기 인터럽트
            - CPU에 의해 발생하는 인터럽트
            - 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
            - 예외라고도 부름
        - 비동기 인터럽트
            - 주로 입출력장치에 의해 발생하는 인터럽트
            - 입출력장치가 CPU에 알림(인터럽트)를 보냄
            - 하드웨어 인터럽트라고도 함
            - 하드웨어 인터럽트 처리 순서
                1. 입출력 장치가 CPU에 인터럽트 요청 신호 전송
                2. CPU는 실행 사이클이 끝난 후 인터럽트 여부 확인
                3. 인터럽트 요청 확인 후 인터럽트 플래그를 통해 인터럽트를 받아들일 수 있는지 확인
                4. 받아들일 수 있다면 지금까지의 작업을 백업
                5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행
                6. 루틴 실행이 끝나면 백업해둔 작업을 복구하여 실행 재개
