# 03-1. 소스 코드와 명령어 
## 컴파일 언어와 인터프리터 언어
### 컴파일 언어 
컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어 
### 인터프리터 언어 
인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어 
### 링킹 
main.c 컴파일 -> main.o 목적 파일 생성 (저급 언어로 변환이 된 파일일 뿐 어떻게 실행되는지는 알지 못한다. import 한 외부 기능을 알지 못한다) -> main 파일에 없는 내용을 연결짓는 작업 == 링킹 
# 03-2. 명령어의 구조
## 연산 코드와 오퍼랜드 
연산 코드 (연산자): 연산에 사용할 데이터 
오퍼 랜드 (피연산자): 연산에 사용할 데이터가 저장된 위치 
### 오퍼랜드
주소 필드라고도 불림
연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치
데이터 또는 메모리/레지스터의 주소 
오퍼랜드의 개수에 따라 N-주소 명령어로 부름 (0~)
### 연산 코드 
1. 데이터 전송 
2. 산술/논리 연산 
3. 제어 프름 변경 
4. 입출력 제어 
## 주소 지정 방식
오퍼랜드의 크기가 커지면 오퍼랜드에 해당 데이터 값을 직접 넣는 것은 비효율적 
-> 오퍼랜드에 데이터의 위치를 명시한다 
이와 같은 방식으로 데이터의 위치를 찾는 방식을 주소 지정 방식이라 한다 
#### 즉시 주소 지정 방식
연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시 
연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기에 다른 방식보다 빠르다
#### 직접 주소 지정 방식 
오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식 
#### 간접 주소 지정 방식 
유효주소의 주소를 오퍼랜드 필드에 명시
직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어짐 
느림 
#### 레지스터 주소 지정 방식 
연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
cpu 내부 메모리에 직접 접근하는 것이기에 빠르다 
표현할 수 있는 레지스터 크기에 제한이 생길 수 있다 
#### 레지스터 간접 주소 지정 방식
연산에 사용할 데이터를 메모리에 저장하고 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명식 
메모리에 접근하는 횟수가 한 번으로 줄어든다 
#### 정리 
주소 지정 방식: 연산에 사용할 데이터를 찾는 방식
유효 주소: 연산에 사용할 데이터가 저장된 위치 
