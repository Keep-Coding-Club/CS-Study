# 05-1. 빠른 CPU를 위한 설계 기법
## 클럭
1. 컴퓨터 부품들은 클럭 신호에 맞춰 일사불란하게 움직인다 
2. CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어들을 실행한다 
-> 클럭 속도가 높으면 CPU는 명령어 사이클을 더 빠르게 반복 
=> 클럭 속도가 높으면 CPU 성능이 좋다 
클럭 속도 : 헤르츠 단위, 클럭속도는 일정하지 않다 
오버클럭킹: 최대 클럭 속도를 강제로 끌어올리는 방법 
## 코어와 멀티코어 
코어: 명령어를 실행하는 부품 
코어 수가 많아진다고 성능이 좋아지는 것은 아니다 
처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에 크게 영향이 없다 
코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐에 따라 연산속도가 크게 달라진다 
## 스레드와 멀티 스레드 
스레드: 실행 흐름의 단위 (CPU 스레드와 프로그래밍 스레드는 다르다)
### 하드웨어적 스레드 
하나의 코어가 동시에 처리하는 명령어 단위 
멀티 스레트 프로세서 (멀티 스레드 CPU): 하나의 코어로 여러 명령어들을 동시에 처리하는 CPU
하이퍼스레딩: 인텔의 멀티스레드 기술
### 소프트웨어적 스레드 
하나의 프로그램에서 독립적으로 실행되는 단위 
# 05-2. 명령어 병렬 처리 기법
## 명령어 파이프라인 
명령어 처리 과정 
1. 명령어 인출 
2. 명령어 해석
3.  명령어 실행 
4. 결과 저장 
명령어 파이프라인: 공장 생산 라인처럼 명령어들을 동시에 처리하는 기법
파이프라인 위험: 특정 상황에서 성능 향상에 실패하는 경우 (데이터 위험, 제어 위험, 구조적 위험이 포함된)
### 데이터 위험 
명령어 간 데이터 의존성에 의해 발생 
이전 명령어를 완료해야만 해당 명령어를 실행할 수 잇는 경우 
데이터 의존적인 두 명령어를 무작정 동시에 실행하려하면 파이프라인이 제대로 작동하지 않는 것 
### 제어 위험 
분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생 
프로그램 카운터 값에 갑작스러운 변화가 생기면 명령어 파이프라인에 미리 가지고 와서 처리중이었던 명령어들은 쓸모가 없어지는 상황 
사용 기술: 분기 예측 - 프로그램이 어디로 분기할지 미리 예측한 뒤 그 주소를 인출하는 것 
### 구조적 위험 
명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU부품을 사용하려 할 때 발생 
자원위험이라고도 부름 
## 슈퍼 스칼라 
여러 개의 명령어 파이프라인을 포함한 구조 
공장 생산 라인을 여러개 두는 것과 같음
## 비순차적 명령어 처리 
OoOE
명령어를 순차적으로 실행하지 않는 기법
# 05-3. CISC, RISC
## 명령어 집합 
== 명령어 집합 구조 (ISA)
CPU가 이해할 수 있는 명령어들의 모음
CPU마다 ISA가 다를 수 있음
CPU 마다 이해할 수 있는 어셈블리어가 달라짐
## CISC
complex instruction set computer 
복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
가변 길이 명령어 사용 
## RISC
CICS의 한계가 준 교훈
1. 빠른 처리를 위해 명령어 파이프라인을 활용해야 한다. 원활한 파이프라이닝을 위해 명령어의 길이와 수행 시간이 짧고 규격화 되어 있어야 한다 
2. 자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것이 중요하다 
reduced instrucion set computer 
짧고 규격화된, 되도록이면 1 클럭 내외로 실행되는 명령어를 지향 
=> 명령어 파이프라이닝에 최적화 
고정 길이 명령어 사용
레지스터 적극 활용 
