## 1. 0과 1로 숫자를 표현하는 방법

<핵심 키워드>

`비트`

`바이트`

`이진법`

`2의보수`

`십육진법`

### 정보 단위

컴퓨터는 0과 1밖에 이해하지 못함.

- 이때 0과 1을 나타내는 가장 작은 정보 단위→ 비트
- 8개의 비트를 묶은 단위 → 바이트
- 바이트를 제외한 kB, MB, GB, 그 이상의 단위들 → 모두 이전 단위를 1000개 묶어 표현한 단위
- 워드: CPU가 한 번에 처리할 수 있는 데이터 크기.
  - e.g. 인텔 x86 CPU : 32비트 워드 CPU, x64 CPU : 64비트 워드 cpu

## 이진법

수학에서 0과 1만으로 모든 숫자를 표현하는 방법

- 숫자 10 → 십진수? 이진수? 구분 불가.
  - 혼동 방지를 위해 이진수 끝에 아래첨자(2)를 붙이거나 숫자 앞에 0b를 붙임.

### 이진수의 음수 표현

- 0과 1만으로 음수를 표현하는 방법 → `2의 보수`
  - 2의 보수: 어떤 수를 그 보다 큰 2^n에서 뺀 값
    e.g. 11(2)의 2의 보수 →11(2)보다 큰 2^n, 즉 100에서 11(2)를 뺀 01(2)
- 2의 보수를 쉽게 표현 → **모든 0과 1을 뒤집고, 거기에 1을 더한 값**
- 어떤 수의 음수를 구한다음, 이 값이 음수임을 확인하려면, 한번 더 음수인지 확인.
- 즉, 어떤 수의 2의 보수를 2번 구해보면 자기자신이 됨.
- -1011(2)을 표현하기 위한 음수으로서의 0101(2)과 십진수 5를 표현하기 위한 양수로서의 0101(2)은 똑같은데 어떻게 구분?
  - 컴퓨터 내부에서 이 수가 양수인지 음수인지를 구분 → **flag(플래그)** 사용
- 2의 보수 표현의 한계
  0이나 2^n형태의 이진수에 2의 보수 → 음수값 x
  0의 경우) 자리 올림이 발생한 비트의 1을 버림.
  2^n의 경우) 2^n의 보수를 취하면 자기 자신이 되어버리는 문제는 본질적 해결 x
  즉, n비트로는 -2^n과 2^n이라는 수를 동시 표현 불가.

## 16진법

- 이진법은 0과 1만으로 모든 숫자 표현 → 숫자의 길이가 너무 길어짐.
- 따라서 데이터를 표현할 때 16진법도 많이 사용
- 이진수와 마찬가지로 숫자뒤에 아래첨자(16)를 붙이거나 숫자 앞에 0x를 붙여 구분.
- 이진수 → 16진수, 16진수 → 2진수로 변환 쉽기에 16진수 사용

### 16진수를 2진수로 변환

16진수 → 한 글자 당 열여섯종류(0~9, A~F)숫자 표현 가능

- 16진수를 이루는 숫자 하나 → 이진수로 표현하려면 몇 비트 필요?

→ 4비트 필요(2^4=16)

- 16진수 → 2진수로 변환하는 쉬운 방법
  - 16진수 한 글자를 4비트의 이진수로 간주
  - 즉, 16진수를 이루고 있는 각 글자를 따로따로 (4개의 숫자로 구성된)이진수로 변환, 그것들을 이어붙이면 16진수 → 2진수 변환!
  - e.g. 1A2B(16)라는 16진수가 있다고 하자.
    - → 각 숫자 1(16), A(16), 2(16), B(16)를 이진수로 표현 → 0001(2), 1010(2), 0010(2), 1011(2)임.
    - 이 숫자들을 그대로 이어 붙인 값: 0001101000101011(2)이 1A2B(16)를 이진수로 표현한 값임.
      ![스크린샷 2023-08-17 오후 8.31.28.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/abee49a2-2f4c-4b7d-8e51-f28505a74339/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-08-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.31.28.png)

### 2진수 → 16진수로 변환

2진수 숫자를 네개씩 끊고 끊어준 네 개의 숫자를 하나의 16진수로 변환 → 그대로 이어 붙임.

e.g. 11010101(2)라는 2진수가 있다고 하자.

1101(2), 0101(2)를 16진수로 표현 → D(16), 5(16)이므로 이를 붙인 값 D5(16)가 11010101(2)를 16진수로 변환한 값임.

이때, 2진수를 십진수로 변환할 때는 이렇게 간단하지 않으므로 2진수를 16진수로 묶어 표현함.

# 2. 0과 1로 문자를 표현하는 방법

<핵심 키워드>

`문자 집합`

`아스키 코드`

`EUC-KR`

`유니코드`

## 문자 집합과 인코딩

- 문자 집합: 컴퓨터가 인식하고 표현할 수 있는 문자의 모음.
  - 컴퓨터는 문자 집합에 속해있는 문자는 이해할 수 있으나 속해있지 않은 문자는 이해불가.
- 문자 인코딩: 문자를 0과 1로 변환하는 과정
- 문자 디코딩: 0과 1로 이뤄진 문자 코드를 문자로 변환하는 과정.

## 아스키 코드

- 아스키: 초창기 문자 집합 중 하나로, 영어 알파벳/ 아라비아 숫자/일부 특수문자 포함.
- 아스키 문자: 아스키 문자 집합에 속한 문자 → 각각 7비트로 표현.
  - 실제로는 하나의 아스키 문자를 나타내기 위해 8비트 사용
    - 8비트 중 1비트는 패리티 비트(오류 검출 비트)이므로 실질적으로 문자 표현에는 7비트만 사용됨.
- 아스키 문자 → 0~127까지 총 128개의 숫자 중 하나의 고유한 수에 일대일 대응
- 아스키 코드: 아스키 문자에 대응된 고유한 수.
  - 아스키 코드를 2진수로 표현함으로써 아스키 문자를 0과 1로 표현 가능.
- 아스키 코드 장점
  - 인코딩이 간단하다.
- 아스키 코드 단점
  - 한글 표현 불가(아스키 문자 집합 외 문자포함)
  - 8비트의 확장아스키 등장(그럼에도 표현 가능한 문자의 수: 256여개)

## EUC-KR

- 한글 인코딩을 이해하려면 한글의 특수성을 알아야 함.
  - 각 음절 하나하나가 초성, 중성, 종성의 조합으로 이뤄짐.
  - 한글 인코딩: `완성형`, `조합형` 존재
- 완성형 인코딩: 초성, 중성, 종성의 조합으로 이뤄진 하나의 글자에 고유한 코드 부여.
- 조합형 인코딩: 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당해 그것들의 조합으로 하나의 글자 코드 완성하는 인코딩 방식.
- EUC-KR: 완성형 인코딩 방식
  - 초성, 중성, 종성이 모두 결합된 한글 단어에 2byte 크기의 코드 부여
- 아스키 코드보다 표현할 수 있는 문자가 많아졌지만 모든 한글 조합을 표현할 수 있을 정도는 아님.

→ 마이크로소프트의 CP949 등장(EUC-KR의 확장, 그러나 한글 전체를 표현하기에는 넉넉한 양 아님)

## 유니코드와 UTF-8

🙄: ‘모든 나라 언어의 문자 집합과 인코딩 방식 통일된다면 좋겠다..

모든 언어를 아우르는 문자 집합과 통일된 표준 인코딩 방식이 있다면.. 언어별로 인코딩하는 수고로움을 덜지 않을까?’

→ 그래서 등장한 유니코드 문자 집합.

- 아스키 코드, EUC-KR→ 글자에 부여된 값 그대로 인코딩 값으로! → 유니코드는 조금 다름.
- UTF-8, UTF-16 등 유니코드 문자를 인코딩하는 방식이 다름.
