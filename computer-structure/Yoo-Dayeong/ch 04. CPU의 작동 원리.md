# 1. ALU와 제어장치

💫 핵심키워드

- ALU
- 플래그
- 제어장치
- 제어 신호

## ALU

![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-17%20%EC%98%A4%ED%9B%84%209.20.20.png)

- CPU내 계산을 담당하는 산술연산장치

<받아들이는 정보>

- 레지스터를 통해 **피연산자**
- 제어장치로부터 수행할 연산을 알려주는 **제어신호**
- 피연산자와 제어 신호로 산술, 논리 연산 등 다양한 연산 수행

<내보내는 정보>

- ALU의 결과값을 메모리가 아니라(속도 저하 방지) 레지스터에 우선 저장.
- ALU의 결과값 + **플래그** 내보냄.

### 🧐 플래그?

- 연산 결과에 대한 추가적인 정보
- ALU가 내보내는 대표적인 플래그

  ![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-17%20%EC%98%A4%ED%9B%84%209.23.49.png)

- 플래그 → 플래그 레지스터에 저장.

## 제어장치

- 제어 신호를 내보냄/명령어 해석
  - **제어 신호: 컴퓨터 부품들을 관리, 작동하기 위한 전기 신호**
- CPU의 구성 요소 중 가장 정교하게 설계된 부품.
  ![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-17%20%EC%98%A4%ED%9B%84%209.26.03.png)

<제어장치가 받아들이는 정보>

1. `클럭 신호`
   - 클럭: 컴퓨터 부품 움직이는 시간 단위
   - 모든 부품이 한 클럭마다 작동한다고 이해x → 하나의 명렁어가 여러 클럭어 걸쳐 실행 가능
2. `해석해야 할 명령어`
   - CPU가 해석해야 할 명령어→ 명령어 레지스터 저장
   - 제어장치: 명령어 레지스터 → 해석할 명령어 받아들임 → 제어 신호를 내보냄.
3. 플래그 레지스터 속 `플래그`
   - 제어장치가 제어 신호를 통해 컴퓨터 부품 제어시 ALU 연산에 대한 추가적인 상태 정보를 이용
4. `제어 버스로 전달된 제어 신호`
   - 제어 신호 → CPU 뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생
   - 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호 받아들임.

<제어장치가 내보내는 정보>

1. CPU 외부에 전달하는 제어 신호
   1. 제어 버스로 제어 신호를 내보냄
   2. 제어 신호 →메모리에 전달하는 제어 신호 / 입출력장치에 전달하는 제어 신호
2. CPU 내부에 전달하는 제어 신호
   1. ALU에 전달하는 제어 신호: 수행할 연산 지시
   2. 레지스터에 전달하는 제어 신호: 레지스터 간에 데이터 이동, 레지스터에 저장된 명령어 해석

# 2. 레지스터

⭐️ 핵심 키워드

`프로그램 카운터`

`명령어 레지스터`

`메모리 주소/버퍼 레지스터`

`범용/플래그 레지스터`

`스택 포인터`

`베이스 레지스터`

## 반드시 알아야 할 레지스터

### 1. 프로그램 카운터

- 메모리에서 가져올 **명령어 주소** 저장

### 2. 명령어 레지스터

- 메모리에서 읽어 들인 **명령어** 저장
- 명령어를 해석 → 제어 신호

### 3. 메모리 주소 레지스터

- **메모리의 주소** 저장
- CPU가 읽어 들이고자 하는 주소 값→ 주소 버스로 보낼 때 메모리 주소 레지스터 거침.

### 4. 메모리 버퍼 레지스터

- 메모리와 주고받을 값(데이터, 명령어)을 저장하는 레지스터

👩‍💻 <메모리에 저장된 프로그램을 실행하는 과정>

1. CPU로 실행할 프로그램이 1000번지~1500번지까지 저장되어 있다고 가정
   - 1000번지에는 1101(2)가 저장.
2. **프로그램 카운터**에는 1000이 저장(메모리에서 가져올 명령어: 1000번지 위치)
3. 1000번지를 받아들이기 위해 주소 버스로 1000번지 내보내야! → **메모리 주소 레지스터에는** 1000이 저장.
4. `메모리 읽기`제어신호와 메모리 주소 레지스터 값이 각각 제어 버스, 주소 버스로 메모리에 보내짐.

5. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 **메모리 버퍼 레지스터**로 전달. **프로그램 카운터**는 증가되어 다음 명령어를 읽어들일 준비.

6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동

7. **제어장치**는 명령어 레지스터의 명령어 해석, 제어 신호 발생.
8. (5)에서 프로그램 카운터 값 증가 확인 → 1000번지 명령어 처리 끝나면 CPU는 다음 명령어(1001번지) 읽어들임.

→ 프로그램 카운터는 지속적 증가를 통해 다음 명령어 받아들임. 이 과정이 반복되면서 CPU는 프로그램을 차례대로 실행.

### 5. 범용 레지스터

- 일반적인 상황에서 다양하게 사용될 수 있는 레지스터
  - 메모리 버퍼 레지스터: 데이터 버스로 데이터만 저장
  - 메모리 주소 레지스터: 주소 버스로 주소만 저장
- 데이터/주소 모두 저장 가능

### 6. 플래그 레지스터

- ALU 연산 결과에 따른 플래그를 저장
- 연산 결과 / CPU 상태에 대한 부가적인 정보 저장

## 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식

- 스택 포인터: `스택 주소 지정 방식` 에 사용됨
- 프로그램 카운터, 베이스 레지스터: `변위 주소 지정 방식`에 사용됨

🪣 **스택 주소 지정 방식**

- 스택, 스택 포인터를 이용한 주소 지정 방식
- 스택포인터: 스택의 꼭대기를 가리키는 레지스터
- 스택: 메모리 안에 존재.

## 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식

- 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더해 유효 주소를 얻어내는 주소 지정 방식.

- 변위 주소 지정 방식을 사용하는 명령어
  - 연산 코드 필드
  - 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드
  - 주소를 담고있는 오퍼랜드 필드 존재.
    - 이때 오퍼랜드 필드 주소, 어떤 레지스터를 더하는지에 따라 `상대 주소 지정 방식` , `베이스 레지스터 주소 지정 방식` 등으로 나뉨.

### 상대 주소 지정 방식

- 오퍼랜드, 프로그램 카운터의 값을 더해 유효 주소를 얻어내는 방식
- 오퍼랜드가 음수라면, CPU는 읽어들이기로 한 명령어로부터 세번째 이전 번지로 접근

### 베이스 레지스터 주소 지정 방식

- 오퍼랜드, 베이스 레지스터의 값을 더해 유효 주소를 얻어내는 방식
- 베이스 레지스터: `기준 주소`
- 오퍼랜드: `기준 주소로부터 떨어진 거리`

즉, 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지 연산해 유효 주소를 얻어내는 방식.

# 3. 명령어 사이클과 인터럽트

😗 핵심키워드

`명령어 사이클`

`인터럽트`

`예외`

`하드웨어 인터럽트`

`인터럽트 서비스 루틴`

## 명령어 사이클

- 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행.
- 인출 사이클: 메모리에 있는 명령어를 CPU로 가져오는 단계
- 실행 사이클: CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클: 메모리 접근이 더 필요할 경우(간접 주소 지정 방식) 메모리 접근 한번 더 하는 단계.

## 인터럽트

- CPU 작업을 방해하는 신호

동기 인터럽트

- CPU에 의해 발생하는 인터럽트(==예외)

비동기 인터럽트

- 입출력장치에 의해 발생하는 인터럽트(==하드웨어 인터럽트)
