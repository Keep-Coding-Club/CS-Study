# 1. 빠른 CPU를 위한 설계 기법

😀 핵심 키워드

- 클럭
- 코어
- 멀티코어
- 스레드
- 멀티스레드

## 클럭

- 클럭 신호가 빠르게 반복 → CPU 를 비롯한 컴퓨터 부품은 빠른 박자로 실행.
  - 클럭 속도가 높은 CPU 성능 ↑
- 클럭 속도: 헤르츠(Hz)단위로 측정
  - 1초에 클럭이 몇 번 반복되는지
  - 실제로는 1초에 25억(2.5GHz), 순간적으로 최대 49억(4.9GHz) 반복
- 클럭 속도를 높이면 CPU를 빠르게 만들지만 클럭 속도만으로 CPU 성능을 올리는 데는 한계 존재.

## 코어와 멀티코어

- 클럭 속도 높이는 방법 외에 CPU 성능 높이는 방법
  - CPU 코어 수 증가
  - CPU 스레드 수 증가

1.  **CPU 코어 수 증가**

    1. 코어: `명령어를 실행하는 부품`(하드웨어 부품)
    2. 오늘날의 CPU는 명령어를 실행하는 부품을 여러개를 포함하는 부품
    3. 코어 여러개 포함 CPU → 멀티코어CPU , 멀티코어 프로세서

       즉, CPU안에 명령어를 실행하는 하드웨어 부품이 2개 이상있는 CPU

    4. 코어를 100개로 늘리면 100배로 빨라질까?

       아니다. 팀플할때 4인 1조로 한다고 해서 모든 경우에 4명 다 참여하는 건 아님.

2.  **CPU 스레드 수 증가**

    스레드: `실행 흐름의 단위`(명령어를 실행하는 단위)

    1.  **하드웨어적 스레드**
        - 하나의 코어가 **동시에 처리하는** 명령어 단위
        - CPU에서 사용하는 스레드 →보통 CPU 입장에서 정의된 하드웨어적 스레드임.
        - e.g. 2코어 4스레드
          ![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-18%20%EC%98%A4%ED%9B%84%203.24.32.png)
          하나의 코어로 여러 명령어를 동시에 처리하는 CPU →멀티스레드 프로세서, 멀티스레드 CPU
        - 하이퍼스레딩: 인텔의 멀티스레드 기술
    2.  **소프트웨어적 스레드**
        - 하나의 **프로그램에서 독립적으로 실행**되는 단위

    ### 멀티스레드 프로세서

    - 하나의 코어로 여러 명령어를 동시에 처리
      → 프로그램 카운터, 스택 포인터, 데이터 버퍼 레지스터, 데이터 주소 레지스터와 같이 하나의 명령어 처리에 필요한 레지스터를 여러개 가지면 됨.

## 2. 명령어 병렬 처리 기법

🙃 핵심 키워드

- 명령어 파이프라이닝
- 슈퍼스칼라
- 비순차적 명령어 처리 기법

빠른 CPU → 높은 클럭 속도, 멀티 코어, 멀티 스레드를 지원하는 CPU를 만드는 것도 중요하지만.. CPU가 놀지 않고 작동하게 만드는 것도 중요함.

- **명령어 병렬 처리 기법**: 명령어를 동시에 처리해 CPU를 쉬지 않고 작동
  - 명령어 파이프 라이닝
  - 슈퍼스칼라
  - 비순차적 명령어 처리 기법

## 명령어 파이프라인

하나의 명령어 처리되는 과정을 클럭 단위로 나눔

1. 인출(Fetch)
2. 해석(Decode)
3. 실행(Execute)
4. 저장(Write)

- 전공서에 따라 순서가 달라지기도 함.

같은 단계가 겹치지만 않는다면 CPU는 각 단계를 **동시에** 실행 가능

**`명령어 파이프라이닝` :** 명령어를 **명령어 파이프라인**에 넣고 동시에 처리하는 기법

**파이프라이닝**-높은 성능 but 특정 상황에서 성능 향상에 실패할수도..

- 파이프라인 위험
  - 데이터 위험
  - 제어 위험
  - 구조적 위험

### 데이터 위험

- 원인: 데이터 의존성
- 어떤 명령어는 이전 명령어를 끝까지 실행해야만 실행할 수 있는 경우

### 제어 위험

- 원인: (분기 등) 프로그램 카운터의 갑작스런 변화
- 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어는 무쓸모.
  ![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-18%20%EC%98%A4%ED%9B%84%204.07.53.png)
- 해결: `분기 예측`
  - `분기 예측한 후 그 주소를 인출`

### 구조적 위험

- 원인: 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생(= 자원 위험이라고도 함)

### 슈퍼스칼라

- CPU 내부에 **여러개의 명령어 파이프라인**을 포함한 구조
- 마치 공장 생산 라인을 여러개 두는 것
- 매 클럭 주기마다 동시에 여러 명령어 인출, 해석, 실행 가능해야.
- 파이프라인 위험 등의 문제로 고도 설계되어야 함.

## 비순차적 명령어 처리(OoOE)

- 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분 CPU가 차용하는 기법
- 명령어의 `합법적 새치기` 기법
- 명령어의 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행해 명령어 파이프라인이 멈추는 걸 방지하는 기법

# 3. CISC와 RISC

🥹 핵심키워드

- ISA
- CISC
- RISC

## 명령어 집합

- **CPU가 이해할 수 있는 명령어들의 모음**(=명령어 집합 구조=Instruction Set Architecture, **ISA**)
- 인텔 CPU: `x86`, `x86-64 ISA`
- 아이폰 CPU: `ARM ISA`
- 같은 소스코드로 만들어진 프로그램이라도 ISA가 다르면 CPU가 이해할 수 있는 명령어 + 어셈블리어 → 달라짐!
  ![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-18%20%EC%98%A4%ED%9B%84%204.16.08.png)
- CPU가 이해하는 명령어가 달라지면…마치 나비효과🦋
  - 제어장치가 명령어를 해석 하는 방법
  - 사용되는 레지스터의 종류와 개수
  - 메모리 관리 방법
  - 등등…
    → 하드웨어 설계에도 큰 영향.

## CISC(Complex Instruction Set Computer)

- 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
- CPU 설계 방식.
- `대표적 CISC 기반의 ISA:`
  - `x86`, `x86-64`
- 다양하고 강력한 명령어 집합 활용 → 명령어의 형태와 크기가 다양한
  - **가변 길이 명령어** 활용
- 메모리를 최대한 아껴 개발해야 했던 시절에 인기 높았음.
- 치명적인 단점(CISC 한계)
  - 명령어가 워낙 복잡, 다양하기에 → 명령어 크기, 실행되기까지의 시간 **일정 x**
  - 복잡한 명령어 때문에 여러 클럭 주기 필요 → **파이프라인 불가**(현대 CPU 치명적 약점)
  - 복잡한 명령어 중 실사용은 20%

## RISC(Reduced Instruction Set Computer)

- 짧고 규격화된 명령어 사용 → 1클럭 내외로 실행되는 명령어
  - 고정 길이 명령어 활용
- 파이프라이닝 최적화
- 메모리 직접 접근 명령어: load, store로 제한(load-store 구조)
  - 적은 주소 지정 방식
