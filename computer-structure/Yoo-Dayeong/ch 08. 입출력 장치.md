# 1. 장치 컨트롤러와 장치 드라이버

🦋 핵심키워드

- 장치 컨트롤러
- 장치 드라이버

## 장치 컨트롤러

- 다양한 입출력장치와 정보를 주고받는 방식을 규격화하기 어려움
- CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮음
- **장치 컨트롤러**: 입출력 제어기, 입출력 모듈 등으로 불림
  - 각자의 장치 컨트롤러를 통해 컴퓨터 내부와 정보 주고받음.
- **CPU와 입출력장치 간의 통신 중개**
- **오류 검출**
- **데이터 버퍼링**
  - 전송률이 높은 장치와 낮은 장치 사이에서 주고받는 데이터를 `버퍼` 라는 임시 저장 공간에 저장해 전송률을 맞추는 방법

<장치 컨트롤러의 간략화된 내부>

![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-23%20%EC%98%A4%ED%9B%84%203.17.42.png)

- **데이터 레지스터**: CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터(버퍼 역할)
- **상태 레지스터:** 입출력 장치의 상태 정보 저장
- **제어 레지스터:** 입출력 장치가 수행할 내용에 대한 제어 정보와 명령 저장

## 장치 드라이버

새로운 장치를 컴퓨터에 연결하려면 장치 드라이버 설치해야 함.

장치 컨트롤러의 동작 감지, 제어 → 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 **프로그램**

- 장치 컨트롤러: 입출력장치 연결하기 위한 하드웨어적 통로
- 장치 드라이버: 입출력장치 연결하기 위한 소프트웨어적 통로

# 2. 다양한 입출력 방법

✨ 핵심 키워드

- 프로그램 입출력
- 메모리 맵 입출력
- 고립형 입출력
- 인터럽트 기반 입출력
- DMA 입출력
- 입출력 버스

## 프로그램 입출력

**프로그램 속 명령어로 입출력장치 제어**

CPU가 프로그램 속 명령어를 실행 → 입출력 명령어를 만나면 CPU는 입출력장치에 연결된 `장치 컨트롤러` 와 상호작용 → 입출력작업 수행

e.g. 메모리에 저장된 정보를 하.디에 백업하는 상황

1. “메모리에 저장된 정보를 하.디에 백업한다”는 말은 “하.디에 새로운 정보를 쓴다”와 동일. CPU는 하.디 컨트롤러의 제어 레지스터에 쓰기 명령을 보냄.
2. 하.디 컨트롤러 → 하.디 상태 확인, 하.디가 준비된 상태라면 하.디 컨트롤러는 상태 레지스터에 준비되었다고 표시
3. CPU는 상태레지스터를 주기적으로 읽으며 준비 여부 확인 → 하.디가 준비되었음을 알게 되면 백업할 메모리 정보를 데이터 레지스터에 작성. 아직 백업 작업(쓰기 작업)이 남았다면 1번부터 반복, 쓰기가 끝난다면 작업 종료

🙄 ”CPU가 입출력장치의 주소를 어떻게 알지?..

아니 더 정확하게는 CPU가 장치 컨트롤러의 레지스터들을 어떻게 알지?”

### 메모리 맵 입출력

- 메모리에 접근하기 위한 주소 공간, 입출력장치에 접근하기 위한 주소 공간 → **하나의 주소 공간으로 간주하는 입출력 방법**
  - e.g 1024개의 주소를 표현하는 컴퓨터) 512개는 메모리 주소, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용.
- CPU는 메모리 주소나 장치 컨트롤러의 레지스터나 모두 똑같이 메모리 주소 대하듯 하면 됨.

### 고립형 입출력

- 메모리를 위한 주소 공간, 입출력장치를 위한 **주소 공간을 분리**
- CPU는 입출력장치에 접근하기 위해 메모리 접근하는 명령어와 다른 입출력 명령어 사용해야 함.

## 인터럽트 기반 입출력

인터럽트 : “CPU가 입출력장치에서 처리할 내용을 명령. 입출력장치가 명령어를 수행하는 동안 CPU는 다른 일을 할 수 있음”

입출력장치에 의한 하드웨어 인터럽트 → 입출력장치가 아니라 **장치 컨트롤러**에 의해 발생

장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호를 보내면 CPU는 인터럽트 서비스 루틴 실행.

인터럽트를 기반으로 하는 입출력 : 인터럽트 기반 입출력!

- cf) 폴링
  주기적으로 입출력장치의 상태가 어떤지 체크하는 방식.
  인터럽트 방식보다 CPU의 부담이 더 큼.

인터럽트가 동시에 발생한 경우

- 순차적으로 인터럽트 처리
  - 현실적으로 모든 인터럽트를 순차적으로만 해결할 수 없음
  - 인터럽트 중에서도 더 빨리 처리해야 하는 인터럽트 존재.
- 우선순위로 인터럽트 처리
  - PIC(Programmable Interrupt Controller) 사용
  - 여러 장치 컨트롤러에 연결→ 하드웨어 인터럽트 요청들의 **우선순위 판별**→ CPU에게 처리해야할 하드웨어 인터럽트 알려줌

<PIC의 다중 인터럽트 처리 과정>

1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호 받아들임
2. PIC는 우선순위 판단 → CPU에 처리해야 할 인터럽트 요청 신호 보냄
3. CPU는 PIC에 인터럽트 확인 신호 보냄
4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보냄.
5. CPU 는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 됨. 해당 장치의 인터럽스 서비스 루틴 실행.

## DMA 입출력

프로그램 기반 입출력과 인터럽트 기반 입출력의 공통점: 입출력장치와 메모리 간의 데이터 이동은 CPU가 주도. 이동하는 데이터도 반드시 CPU를 거쳐야 함.

가뜩이나 바쁜 CPU는 입출력장치를 위한 연산때문에 시간을 뺏기게 됨.

따라서 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력방식인 DMA 등장.

- 직접 메모리에 접근할 수 있는 입출력 기능
- DMA 입출력을 하기 위해서는 **시스템 버스**에 연결된 **DMA 컨트롤러**라는 하드웨어 필요

### 입출력 버스

- CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스 공유
- DMA를 위해 한 번 메모리에 접근할 때마다 시스템 버스를 2번 사용하게 되는 부작용.
- DMA를 위해 시스템 버스를 사용하면, CPU는 그만큼 시스템 버스 사용 x
- 따라서 DMA 컨트롤러, 장치 컨트롤러 → `입출력버스`에 연결해 해결
