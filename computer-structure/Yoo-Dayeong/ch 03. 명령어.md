# 1. 소스코드와 명령어

😺 핵심 키워드

- 고급 언어
- 저급 언어
- 기계어
- 어셈블리어
- 컴파일 언어
- 인터프리터 언어

## 고급 언어와 저급 언어

- 고급 언어: 프로그래밍 언어와 같이 사람이 이해하고 작성하기 쉽게 만들어진 언어
- 저급 언어: 컴퓨터가 직접 이해하고 실행할 수 있는 언어
  - 기계어: 0과 1의 명령어 비트로 이뤄진 언어
  - 어셈블리어: 기계어를 읽기 편한 형태로 번역한 언어

## 컴파일 언어와 인터프리터 언어

개발자들이 고급 언어로 작성한 소스 코드 → 저급 언어로 변환 → 실행.

🙄 어떻게 고급언어가 저급언어로 변환?

- 컴파일→ 컴파일 언어
- 인터프리트→ 인터프리터 언어

### 컴파일 언어

컴파일러에 의해 소스코드 전체가 저급 언어로 변환되어 실행되는 고급 언어.

e.g. c언어

- 컴파일러는 소스 코드 전체를 쭉 훑으며 문법 오류 여부 확인, 실행 여부 확인하며 처음부터 끝까지 저급 언어로 컴파일.
- 이때 컴파일러가 소스 코드 내에서 오류를 하나라도 발견 → 소스코드 컴파일 실패.
- 컴파일 성공 → 고급언어에서 저급언어로 변환된 코드: 목적 코드

### 인터프리터 언어

인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어

e.g. Python

- 인터프리터는 소스 코드를 한 줄씩 저급언어로 변환해 실행을 도와줌.
- n번째 줄에 문법 오류가 있더라도 n-1번째 줄까지는 올바르게 수행.
- 컴파일언어 vs 인터프리터 언어
  현대 많은 프로그래밍 언어 중에 컴파일 언어와 인터프리터 언어 간의 경계가 모호한 경우가 많음.
  Python: 컴파일 하지 않은 건 아님, Java: 저급언어가 되는 과정에서 컴파일과 인터프리트 동시에 수행.
- 목적 파일 vs 실행 파일
  컴파일후의 목적 코드가 실행 파일이 되기 위해서는 `링킹` 이라는 작업 필수

# 2. 명령어의 구조

😺 핵심 키워드

- 명령어
- 연산 코드
- 오퍼랜드
- 주소 지정 방식

## 연산 코드와 오퍼랜드

우리는 누군가에게 명령할때..

🥸: “학생들, 다음주까지 과제를 제출하세요”

🥸: “영희야, 방 좀 치워줘”

🥸: “멍멍아, 이거 물어봐”

- 컴퓨터 속 명령어도 마찬가지임.
- “`무엇을` 대상으로 `어떤` 작동을 수행해라!” 라는 구조

명령어: **연산 코드**, **오퍼랜드**로 구성

- 연산 코드: 명령어가 수행할 연산
- 오퍼랜드(피연산자): 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치

### 오퍼랜드

- 연산에 사용할 **데이터가 저장된 위치** 명시
  → 메모리 주소 or 레지스터 이름(오퍼랜드==주소 필드)
- 오퍼랜드가 없는 명령어: 0-주소 명령어
- 오퍼랜드가 1개인 명령어: 1-주소 명령어
- 오퍼랜드가 2개인 명령어: 2-주소 명령어
- 오퍼랜드가 3개인 명령어: 3-주소 명령어

### 연산 코드

- 명령어가 수행할 연산
- 기본적인 연산 코드 유형
  - 데이터전송
  - 산술/논리 연산
  - 제어 흐름 변경
  - 입출력 제어

## 주소 지정 방식

🙄: ‘명령어의 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많다.. 그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다..’

‘왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는건가? 그냥 <연산 코드, 연산 코드에 사용될 데이터> 형식으로 명령어를 구성하면 되지 않나?’

→ `명령어 길이` 때문에!

하나의 명령어가 n비트로 구성, 그 중 연산 코드 필드가 m비트라고 가정.

오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어도 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m비트임.

- 2-주소 명령어, 3-주소 명령어는 오퍼랜드 필드의 크기는 더욱 작아짐.

하지만 오퍼랜드 필드 안에 `메모리 주소`가 담긴다면 표현할 수 있는 데이터 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커짐.

e.g. 한 주소에 16비트를 저장할 수 있는 메모리

메모리 안에 데이터 저장, 오퍼랜드 필드 안에 해당 메모리 주소를 명시 → 표현할 수 있는 정보의 가짓수가 2^16으로 커짐.

![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-17%20%EC%98%A4%ED%9B%84%209.09.25.png)

![](./asset/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-08-17%20%EC%98%A4%ED%9B%84%209.10.32.png)

- 연산 코드에 사용할 데이터가 저장된 위치
- 즉, 연산의 대상이 되는 데이터가 저장된 위치: `유효 주소`
- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치(유효 주소)를 찾는 방법: `주소 지정 방식`
- 현대 CPU는 다양한 주소 지정 방식 사용(대표적인 **5가지** 살펴보자)

### 즉시 주소 지정 방식

- **연산에 사용할 데이터**를 오퍼랜드 필드에 직접 명시
- 가장 간단.
- 데이터의 크기가 작아지는 단점
- 메모리, 레지스터로부터 데이터 찾는 과정 없기에 빠름.

### 직접 주소 지정 방식

- 오퍼랜드 필드에 **유효 주소**를 직접적 명시
- 오퍼랜드 필드의 데이터 크기 ≥ 즉시 주소 지정 방식의 오퍼랜드 필드의 데이터 크기
- 오퍼랜드 필드의 길이가 연산 코드만큼 짧아져 유효 주소 제한.

### 간접 주소 지정 방식

- **유효 주소의 주소**를 오퍼랜드 필드에 명시
- 2번의 메모리 접근 → 느림.

### 레지스터 주소 지정 방식

- 연산에 사용할 데이터가 레지스터에 저장된 경우
- **연산에 사용할 데이터를 저장한 레지스터**를 오퍼랜드 필드에 직접 명시
- CPU 외부에 위치한 메모리에 접근하는 것보다 CPU 내부에 위치한 레지스터에 접근하는 게 더 빠름.
- 그러나 표현할 수 있는 레지스터 크기에 제한이 생김.

### 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 메모리에 저장.
- 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시.
- 유효 주소를 찾는 과정이 간접 주소 지정과 비슷하지만 메모리 접근 횟수→ 1번으로 줄음.
