자료구조를 정의하고 기본 자료구조인 배열에 대해 익히자.

이 책에선 배열을 리스트와 튜플로 구현하니 참고바람.

# 02-1 자료구조와 배열

## 배열?

배열을 사용하면 따로따로 흩어진 변수를 하나로 묶어서 사용해 코드를 쉽고 효율적으로 작성 가능

## 파이썬에서의 배열(리스트 ,튜플)

### 리스트

원소를 변경할 수 있는 mutable한 list형 객체.

연산자 [] 안에 원소를 쉼표(,)로 구분해 표기해 생성

### 튜플

원소에 순서를 매겨 결합한 것으로 원소를 변경할 수 없는 immutable한 자료형.

튜플은 원소를 쉼표로 구분해 나열한 뒤 결합 연산자()로 둘러싸서 생성

리스트와 달리 결합 연산자() 생략 가능

**mutable vs immutable**

값을 변경할 수 있는 특성은 mutable!

값을 변경할 수 없는 특성은 immutable!

<**파이썬에서의 자료형>**

**mutable** 자료형: 리스트, 딕셔너리, 집합

**immutable** 자료형: 수, 문자열, 튜플

## 자료구조

자료구조는 논리적인 관계로 이뤄진 데이터 구성.

즉, 자료구조는 데이터가 모여 있는 구조임.

자료구조를 알아야 하는 이유는 컴퓨터에서 처리해야 하는 많은 데이터를 모아 효율적으로 관리하고 구조화하기 위함임.

# 02-2 배열이란?

배열을 사용하는 기본 알고리즘을 살펴보자.

## 배열 원소의 최댓값을 구하는 함수 구현하기

실습 2-2) 배열 원소의 최댓값을 구하는 함수 프로그램

```python
from typing import Any, Sequence

def max_of(a: Sequence) -> Any:
  '''시퀀스형 a 원소의 최댓값을 반환'''
  maximum=a[0]
  for i in range(1, len(a)):
    if a[i] > maximum:
      maximum = a[i]
  return maximum
if __name__ == '__main__':
  print('배열의 최댓값을 구합니다.')
  num = int(input())
  x = [None]*num # 원소수가 num인 리스트 생성

  for i in range(num):
    x[i] = int(input(f'x[{i}]값을 입력하세요.'))
  print(f'최댓값은 {max_of(x)}입니다.')
```

### 코드 뜯어보기

### 주석과 자료형 힌트

```python
from typing import Any, Sequence
```

Any→ 제약이 없는 임의의 자료형

Sequence → 시퀀스형(리스트형, 바이트 배열형, 문자열형, …)

따라서 두 자료형을 사용해 max_of() 함수를 다음과 같이 정의

```python
def max_of(a: Sequence) -> Any:
```

- 건네받은 매개변수 a의 자료형은 Sequence 임
- 반환하는 것은 임의의 자료형인 Any임.

max_of() 함수 안에서 매개변수에 대한 함수 어노테이션(주석)은 시퀀스형이 아니라 **뮤터블 시퀀스**라 명시함.

### 재사용할 수 있는 모듈 작성하기

파이썬에서는 하나의 스크립트 프로그램을 **모듈**이라고 함.

확장자(.py)를 포함하지 않은 **파일의 이름 자체**를 **모듈이름**으로 사용.

따라서 실습 2-2 프로그램의 파일 이름이 max이므로 모듈이름은 max임.

```python
if __name__ == '__main__':
```

왼쪽 피연산자 `__name__` 은 모듈 이름을 나타내는 변수.

모든 것을 객체로 다루는 파이썬이므로, 모듈도 당연히 객체임.

모듈은 프로그램이 처음 import되는 시점에 그 모듈 객체가 생성되면서 초기화되는 구조.

따라서 실습 2-2 프로그램에서 위 코드는 **해당 파일을 직접 시작한 경우**에만 참이 되어 나머지 행 실행 가능.

만약 다른 스크립트 프로그램에서 import한 경우에는 거짓이 되므로, if문 실행 안됨.

### 모듈 테스트하기

모듈 2-2로 정의된 max_of()함수를 다른 프로그램에서 호출해보자.

_실습 2-3) int형 정수값을 차례로 입력받다가 End 입력하면 더 이상 입력 받지 않고 그 시점에서 원소 수 확정._

```python
from max import max_of

print('배열의 최댓값을 구하자')
print('End 입력시 종료')

number = 0
x= []

while True:
  s = input(f'x[{number}]값을 입력하세요: ')
  if s == 'End':
    break
  x.append(int(s))
  number += 1
print(f'{number}개 입력')
print(f'최댓값은 {max_of(x)}입니다.')
```

모듈 max로 정의된 max_of() 함수를 사용하도록 import.

## 배열 원소를 역순으로 정렬하기

배열 원소를 역순(뒤에서 앞)으로 정렬하는 알고리즘을 생각해보자.

예를 들어 배열 a의 원소가 7개이고 [2, 5, 1, 3, 9, 6, 7]로 저장되어 있다면, 이것을 [7, 6, 9, 3, 1, 5, 2]의 순서로 바꾸어보자.
![image](https://github.com/Keep-Coding-Club/CS-Study/assets/71822139/541ff6c5-6d5f-4e53-9453-2e1ba31bd6e5)

1. 그림의 a처럼, 맨 앞 원소 a[0]과 맨 끝 원소 a[6]의 값을 교환
2. 그림 b,c처럼 각각 하나씩 안쪽의 원솟값을 교환하는 작업 반복

- 교환횟수: 원소수 // 2번
- // 기호를 사용해 `나누기 연산` → 소수점 이하는 버리고 정숫값만 얻음.
- 원소 수가 홀수인 경우 가운데 원소는 교환할 필요 없음.

원소수가 n인 배열에서 i값을 원소의 인덱스라고 하자.

그럼 맨 앞에서 시작하는 왼쪽 원소의 인덱스 → i(n이 7이라면 0,1,2)

오른쪽 원소의 인덱스 → n-i-1(n이 7이라면 6,5,4)

_실습 2-6) 배열 원소를 역순으로 정렬하기_

```python
from typing import Any, MutableSequence

def reverse_array(a: MutableSequence) -> None:
    '''mutable 시퀀스 a의 원소를 역순으로 정렬'''
    n = len(a)
    for i in range(n//2):
        a[i], a[n-i-1] = a[n-i-1], a[i]

if __name__ == '__main__':
    print('배열 원소를 역순으로 출력')
    nx = int(input())
    x = [None]*nx  # 원소 수가 nx인 리스트 생성

    for i in range(nx):
        x[i] = int(input(f'x[{i}]값을 입력하세요'))
    reverse_array(x)  # x를 역순으로 정렬

    print('배열 원소를 역순으로 정렬')
    for i in range(nx):
        print(f'x[{i}]={x[i]}')
```

## 기수 변환하기(n진수 구하기)

정숫값을 임의의 기수로 변환하는 알고리즘을 살펴보자.

10진수 정수를 n진수로 변환하려면 정수를 n으로 나눈 나머지를 구하는 동시에 몫을 반복해서 나눠야 함.

몫이 0이 될때까지 과정 반복.

나머지를 역순으로 늘어놓으면 기수로 변환한 수가 됨.

이때 16진수는 문자 16개로 표현하는 수 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)

따라서 기수가 10을 넘는 경우 0~9까지 이어지는 숫자가 끝나면 알파벳 문자인 A, B,… 를 사용함

_실습 2-7) 기수로 변환하는 프로그램_

```python
# 10진수 정수값을 입력받아 2~36진수로 변환해 출력하기

def card_conv(x: int, r: int) -> str:
  '''정수값 x를 r진수로 변환 후에 수를 나타내는 문자열 반환'''
  d = '' # 변환 후 문자열
  dchar = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'

  while x > 0:
    d += dchar[x%r] # 해당하는 문자를 꺼내 결합
    x //= r
  return d[::-1] # 역순으로 반환!
```

**card_conv**() 함수는 정수 x를 r진수로 변환. 그 수를 문자열로 반환.

x를 r로 나눈 나머지를 인덱스로 하는 문자, 곧 char[x%r]를 문자열 d에 추가.

x가 0이 될때까지 과정 반복. 이때 x를 r로 나눈 나머지의 값 위치에 있는 문자를 d에 결합하므로 문자열 d의 맨 앞은 마지막으로 구한 문자가 됨.

따라서 변환된 문자열 d는 역순으로 출력해야 함. return 문은 슬라이스 식 d[::-1]을 통해 d의 문자열을 역순으로 반환.

_실습 2-7-B) 프로그램의 메인부로 기수 변환 실행_

```python
if __name__ == '__main__':
  print('10진수를 n진수로 변환.')
  while True:
    while True: # 음이 아닌 정수를 입력받음
      no = int(input('변환할 값으로 음이 아닌 정수를 입력하시오.'))
      if no > 0:
        break

    while True: # 2~36진수의 정숫값을 입력받음.
      cd = int(input('어떤 진수로 변환?'))
      if 2<=cd<=36:
        break

    print(f'{cd}진수로는 {card_conv(no, cd)}입니다.')

    retry=input('한번 더 변환? Y-예, N-아니요')

    if retry in {'N', 'n'}:
      break
```

실습 2-7의 card_conv() 함수부분을 다음과 같이 수정해 기수 변환하는 과정을 자세히 나타냄.

```python
# 10진수 정수값을 입력받아 2~36진수로 변환해 출력하기(실습 2-7 수정)

def card_conv(x: int, r: int) -> str:
  '''정수값 x를 r진수로 변환 후에 수를 나타내는 문자열 반환'''
  d = '' # 변환 후 문자열
  dchar = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  n = len(str(x))

  print(f'{r:2} | {x: {n}d}')

  while x>0:
    print(' +'+(n+2)*'-')
    if x//r:
      print(f'{r:2} | {x//r:{n}d} ··· {x%r}')
    else:
      print(f'  {x//r:{n}d} ··· {x%r}')
    d += dchar[x%r]
    x //= r

  return d[::-1] # 역순으로 반환!
```

📔추가 학습) 파이썬에서의 **함수 사이 인수 전달**

함수가 전달받는 매개변수와 호출하는 곳에서 전달하는 실제 인수를 살펴보자.

_실습 2C-5) 1부터 n까지 정수의 합을 구해 반환하는 sum_1_to_n()함수 구현._

```python
def sum_1_to_n(n):
    # 1부터 n까지 정수의 합
    s = 0
    while n > 0:
        s += n
        n -= 1
    return s

x = int(input('x의 값을 입력: '))
print(f'1부터 {x}까지 정수의 합 {sum_1_to_n(x)}')
```

sum_1_to_n()함수의 실행과정에서 매개변수 n값은 5→4→••• 으로 1씩 감소.

함수가 종료될때 n값은 0임.

호출하는 곳에서 sum_1_to_n()함수로 전달하는 실제 인수는 x임.

함수에서 돌아온 뒤 ‘1부터 5까지 정수의 합은 15’라고 출력되므로 변수 x의 값(5)은 호출하기 전의 값 그대로임.

이 결과를 보고 `매개변수 n으로 실제 인수 x의 값이 복사(copy)` 되었다고 생각하면 안된다. ❌

함수의 실행 시작 시점에서 매개변수는 **실제 인수와 같은 객체를 참조**

함수에서 매개변수의 값을 변경하면 인수의 형(type)에 따라 다음과 같이 구분

1. 인수가 **immutable**할 때 : 함수 안에서 매개변수 값을 변경하면 다른 객체 생성. 그 객체에 대한 참조로 업데이트. 따라서 매개변수 값을 변경해도 호출하는 쪽의 실제 인수에는 영향 x
2. 인수가 **mutable**할 때: 함수 안에서 매개변수의 값을 변경하면 객체 자체를 업데이트 함. 따라서 매개변수의 값을 변경하면 호출하는 쪽의 실제 인수는 값이 변경됨

앞에서 실습한 2C-5는 1에 해당됨. 이제 2의 특징인 인수의 형이 mutable인 경우를 생각해보자. mutable 형의 대표인 리스트를 다뤄보자.

```python
# 리스트에서 임의의 원솟값 업데이트

def change(lst, idx, val):
    # lst[idx]값을 val로 업데이트
    lst[idx] = val

x = [11, 22, 33, 44, 55]
print('x=', x)

index = int(input('업데이트할 인덱스 선택: '))
value = int(input('새로운 값 입력: '))

change(x, index, value)
print(f'x={x}')
```

change() 함수는 lst 안에 들어있는 인덱스가 idx인 원소, 즉 lst[idx]에 val을 대입하는 간단한 함수.

인수가 mutable하면 함수 안에서 업데이트한 값이 원래 호출한 곳으로 전달됨.

## 소수 나열하기

어떤 정수 이하의 소수를 모두 나열하는 알고리즘.

소수는 자신과 1 이외의 정수로 나눠 떨어지지 않는 정수.

소수 13은 1과 13을 제외한 어떤 정수로도 나눠 떨어지지 않음.

그러므로 어떤 정수 n은 다음 조건을 만족하면 소수임.

`2부터 n-1까지 어떤 정수로도 나눠 떨어지지 않는다.`

만약 나눠 떨어지는 정수가 하나 이상 존재하면 그 수는 합성수임.

_실습 2-8) 1000이하의 모든 소수를 나열하는 프로그램._

```python
cnt = 0  # 나눗셈 횟수를 카운트

for n in range(2, 1001):
    for i in range(2, n):
        cnt += 1
        if n % i == 0:  # 나눠 떨어지면 소수가 아님
            break
    else:  # 끝까지 나눠 떨어지지 않으면 다음 수행
        print(n)
print(f'나눗셈을 실행한 횟수: {cnt}')
```

- 소수를 구하는 부분은 이중 for문으로 작성.
- 바깥족 for문에서는 n값을 2부터 시작해 1000이 될때까지 1씩 증가시키면서 그 값이 소수인지 판단.
- 나눠 떨어지는 숫자가 나오면 다음 증가하는 과정은 진행 x

여기서 잠깐

만약 n이 2와 3으로 나눠 떨어지지 않는다면 2x2인 4와 2x3인 6으로도 나눠 떨어지지 않음.

즉, 위 프로그램은 불필요한 나눗셈을 계속 실행하는 것.

정수 n이 소수인지 여부는 다음 조건을 만족하는지 알아보면 됨.

`2부터 n-1까지 어떤 소수로도 나눠 떨어지지 않는다.`

예를 들어 7이 소수인지는 7보다 작은 소수인 2, 3, 5로 나눗셈을 실행하는 것만으로도 충분.(4와 6은 하지 않아도 됨)

이 아이디어를 적용해 실습 2-8보다 나눗셈 횟수를 줄이는 프로그램을 작성해보자.

### 알고리즘 개선하기1

- 실습 2-9는 소수를 구하는 과정에서 지금까지 구한 소수를 배열 prime의 원소로 저장하도록 개선
- n이 소수인지 판단할 때 배열 prime에 저장한 소수로 나눗셈을 하면 됨.
- 주의할 점은, 2는 소수인 것이 분명하므로 2를 배열의 첫 원소인 **prime[0]**에 저장해야 함.
- 배열에 저장한 **소수의 개수**를 나타내는 변수 ptr도 선언.

```python
cnt = 0  # 나눗셈 횟수를 카운트
ptr = 0  # 이미 찾은 소수의 개수
prime = [None]*500 # 소수를 저장하는 배열

prime[ptr]=2 # 2는 소수이므로 초기값으로 지정
ptr += 1

for n in range(3, 1001, 2): # 홀수만 대상으로 설정!
  for i in range(1, ptr): # 이미 찾은 소수로 나눔
        cnt += 1
        if n % prime[i] == 0:  # 나눠 떨어지면 소수가 아님
            break
  else:  # 끝까지 나눠 떨어지지 않으면
    prime[ptr] = n
    ptr += 1

for i in range(ptr):
  print(prime[i])

print(f'나눗셈을 실행한 횟수: {cnt}')
```

- n값은 3부터 시작해 소수를 이중 for문으로 구함
- 먼저 바깥쪽 for문에서는 n값을 2씩 증가시켜 3,5, …, 999로 홀수 값만 생성
  - 4이상의 짝수는 2로 나눠 떨어지므로 소수가 아니기에.
- 안쪽 for문에서는 i값을 1부터 시작해 ptr-1번만 반복.
- for문은 prime[i]의 i값(지금까지 구한 소수)로 나눗셈 반복.

### 알고리즘 개선하기2

실습 2-8을 한번 더 개선해보자.

예를 들어 넓이가 100인 직사각형의 가로, 세로 변의 길이를 생각해보자.

5 x 20과 20 x 5는 가로, 세로 변의 길이는 다르지만 같은 직사각형임.

따라서 모든 직사각형은 정사각형은 10 x 10을 경계로 대칭 구조임.

만약 100이 5로 나눠 떨어지지 않는다면 20으로도 나눠 떨어지지 않음.

→ 직사각형 한 변의 길이만 나눗셈을 시도하고, 그 과정에서 한번도 나눠 떨어지지 않는다면 소수라고 판단해도 좋음.

즉, 어떤 정수 n은 다음 조건을 만족하면 소수임

`n의 제곱근 이하의 어떤 소수로도 나눠 떨어지지 않음`

이 아이디어를 적용해 개선한 프로그램이 실습 2-10임.

`prime[i] * prime[i] <= n` 에서는 prime[i]가 n의 제곱근보다 작거나 같은지를 곱셈을 이용해 판단.

**n의 제곱근**을 구하는 것보다 **prime[i]의 제곱**을 구하는 것이 훨씬 간단하고 빠르기 때문임.

```python
cnt = 0  # 나눗셈 횟수를 카운트
ptr = 0  # 이미 찾은 소수의 개수
prime = [None]*500 # 소수를 저장하는 배열

prime[ptr]=2 # 2는 소수
ptr += 1

prime[ptr]=3 # 3은 소수
ptr += 1

for n in range(5, 1001, 2): # 홀수만 대상으로 설정!
  i = 1
  while prime[i] * prime[i] <= n:
    cnt += 2 # 곱셈, 나눗셈의 실행 횟수를 세기때문에
    if n % prime[i] == 0:  # 나눠 떨어지면 소수가 아님
        break
    i += 1
  else:  # 끝까지 나눠 떨어지지 않으면
    prime[ptr] = n
    ptr += 1
    cnt += 1 # 곱셈 횟수는 카운트 X 나눗셈 횟수만 카운트.

for i in range(ptr):
  print(prime[i])

print(f'나눗셈을 실행한 횟수: {cnt}')
```
