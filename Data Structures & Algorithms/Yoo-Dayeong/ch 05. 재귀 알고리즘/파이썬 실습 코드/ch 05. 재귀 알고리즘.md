# 05-1. 재귀 알고리즘의 기본

- 재귀: 어떠한 이벤트에서 자기 자신을 포함하고 다시 자기 자신을 사용해 정의

## 팩토리얼

- 재귀를 사용하는 대표적인 예
- 팩토리얼 n!의 정의(n은 양의 정수)
    - 0! = 1
    - n > 0 이면 n! = n x (n-1)!

```python
# 양의 정수 n의 팩토리얼

def fac(n):
    if n > 0:
        return n * fac(n-1)
    else:
        return 1

n = int(input('팩토리얼 값: '))
print(f'{n}의 팩토리얼: {fac(n)}')
```

- factorial() 함수는 n-1의 팩토리얼 값을 구하기 위해 다시 자신과 똑같은 factorial()함수를 호출 →재귀호출

## 유클리드 호제법

- 두 정숫값의 최대 공약수를 재귀적으로 구하는 방법

2개의 정숫값을 직사각형 두 변의 길이라고 생각하면 두 정숫값의 최대공약수 구하는 문제는

- `직사각형 안을 정사각형 여러 개로 가득 채워나간다. 이렇게 만들 수 있는 정사각형 가운데 가장 작은 정사각형의 변의 길이?`

로 바꿀 수 있다.

수학적으로는,

두 정수 x, y의 최대공약수를 gcd(x, y)로 표기.

예를 들어 x= az, y=bz를 만족하는 정수 a,b와 최대의 정수 z가 존재할때는 z는 gcd(x,y)라고 할 수 있다.

다시 말해 최대 공약수는 다음과 같음.

```
y가 0이면 -> x
y가 0이 아니라면 -> gcd(y, x % y)
```

이 알고리즘을 유클리드 호제법이라고 함.

```python
def gcd(x, y):
  if y == 0:
    return x
  else:
    return gcd(y, x%y)
x=int(input())
y=int(input())
print(f'두 정수의 최대공약수 {gcd(x,y)}')
```

# 05-3. 하노이의 탑

- 쌓아 놓은 원반을 최소 횟수로 옮기는 알고리즘
- 작은 원반이 위에, 큰 원반이 아래에 위치하는 규칙
- 기둥 3개를 이용해 원반을 옮김.

```python
# 원반 no개를 x기둥에서 y기둥으로 옮김

def move(no, x, y):
    if no > 1:
        move(no-1, x, 6-x-y)
    print(f'원반 [{no}]개를 {x}기둥에서 {y}기둥으로 옮김')

    if no > 1:
        move(no-1, 6-x-y, y)

n = int(input())
move(n, 1, 3)
```

- 기둥 번호: 1, 2, 3
- 기둥 번호의 합이 6이므로 시작 기둥, 목표 기둥이 어느 위치에 있든 중간 기둥은 (6-x-y)로 구할 수 있음

# 05-4. 8퀸 문제란?

- 재귀 알고리즘을 설명할 때 자주 나오는 예제
- 19세기 수학자 가우스가 오답을 발표한 것으로 유명

문제

`8개의 퀸이 서로 공격해 잡을 수 없도록 8x8 체스판에 배치하세요`

답

92가지

## 퀸 배치하기

- 퀸 8개를 배치하는 조합이 모두 몇가지?
- 체스판(8x8)이므로 첫번째 퀸을 배치 → 64칸 중 아무데나
- 두번째 퀸을 배치 → 나머지 63칸 중 아무데나
- 이렇게 8번째 퀸을 배치한다면
    
    ```
    64 x 63 x 62 x 61 x 60 x 59 x 58 x 57 = 178,462,987,637,760
    ```
    
    이 조합을 모두 나열하고 각 조합이 8퀸 문제의 조건을 만족하는지 조사하는건 비현실적.
    
    퀸은 자신과 같은 행, 열에 있는 다른 퀸을 공격 가능.
    
    ```
    1. 각 열에 퀸을 1개만 배치
    2. 각 행에 퀸을 1개만 배치
    ```
    

## 분기 작업으로 문제 해결

- 가지를 나누는 식으로 모든 조합을 나열
    - 조합만 나열, 아직 8퀸 문제 해결 x
- 배열 pos : 퀸 배치
    - i열에 배치한 퀸의 위치가 j행에 있다면, pos[i]=j
- set(): pos[i]에 0~7까지 값을 차례로 대입해 i열에 퀸을 1개만 배치하는 8가지 조합을 만드는 재귀 함수.
    - 즉, i는 퀸이 배치될 열

```
set(0)
```

- 호출된 set()함수는 i에 0을 전달받음.
- for문으로 반복 수행 → j를 0~7까지 1씩 증가시키며 pos[i]에 j를 대입해 퀸을 j행에 배치.
    - 이 대입에서 0열의 배치 확정
    - 다음 1열의 배치 필요

```
set(i + 1)
```

이 호출을 통해 0열에서 했던 작업을 다음 열인 1열에서 수행.

```python
pos = [0]*8

def put():
  for i in range(8):
    print(f'{pos[i]:2}', end='')
  print() 
  
def set(i):
  for j in range(8):
    pos[i]=j
    if i == 7:
      put()
    else:
      set(i+1)
      
set(0)
```

- 이와 같이 차례대로 가지가 뻗어 나가듯이 배치 조합 → `분기 작업`

## 한정 작업과 분기 한정법

분기 작업으로 퀸을 배치하는 조합을 나열 가능

그러나 8퀸 문제의 최종 답 x

다음은 앞에서 분기를 한정할 때 정했던 규칙.

```python
2. 각 행에 퀸을 1개만 배치
```

다음 실습은 규칙 2를 적용.

```python
pos = [0]*8
flag = [False]*8  # 각 행에 퀸을 배치했는지 체크

def put():
  for i in range(8):
    print(f'{pos[i]:2}', end='')
  print() 
  
def set(i):
  for j in range(8):
    if not flag[j]: # j행에 퀸 배치 x
      pos[i]=j
      if i == 7:
        put()
      else:
        flag[j]=True
        set(i+1)
        flag[j]=False
      
set(0)
```

- j행에 퀸 배치하면 flag[j]를 True로, 배치하지 않으면 False로.

### 8퀸 문제 해결 프로그램

- 위에서 한 실습은 퀸이 행과  열 방향으로 겹치지 않는 조합 나열
- 그러나 체스에서 퀸은 대각선 방향으로 이동 가능
- 어떤 대각선에서 보더라도 퀸을 1개만 배치하는 한정 작업 추가 필요.

```python
pos = [0]*8
flag_a = [False]*8  # 각 행에 퀸을 배치했는지 체크
flag_b = [False]*8  # 대각선 방향(왼쪽 아래-오른쪽 위) 퀸을 배치했는지 체크
flag_c = [False]*8  # 대각선 방향(오른쪽 아래-왼쪽 위) 퀸을 배치했는지 체크

def put():
  for i in range(8):
    print(f'{pos[i]:2}', end='')
  print() 
  
def set(i):
  for j in range(8):
    if (not flag_a[j] and not flag_b[i+j] and not flag_c[i-j+7]) :
      pos[i]=j
      if i == 7:
        put()
      else:
        flag_a[j]=flag_b[i+j]=flag_c[i-j+7]=True
        set(i+1)
        flag_a[j]=flag_b[i+j]=flag_c[i-j+7]=False      
set(0)
```