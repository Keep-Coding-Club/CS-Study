# ch06 정렬 알고리즘

주차: 1일차, 5주차

## 정렬

> 정렬
: 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업

안정된 정렬
: 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지
> 

- 정렬 순서
    - 오름차순: 키값이 작은 데이터를 앞쪽에 배치
    - 내림차순: 오름차순과 반대로 배치

- 내부 vs 외부 정렬
    - 내부 정렬: 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘
    - 외부 정렬: 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘

## 버블 정렬

> 버블 정렬
: 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복
> 

```cpp
//오름차순 정렬
void bubble(int a[], int n)
{
	for(int i=0; i<n-1; i++){
		if(a[j-1] > a[j])
			swap(int, a[j-i], a[j]);
	}
}

//개선된 버블 정렬(스캔 범위를 제한)
void bubble(int a[], int n)
{
	int k=0;
	while(k<n-1){
		int last=n-1;
		for(int j=n-1; j>k; j--){
			if(a[j-1] > a[j]){
				swap(int, a[j-i], a[j]);
				last=j;
			}
		k=last;
		}
	}
}
```

## 단순 선택 정렬

> 단순 선택 정렬
: 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정하는 알고리즘

교환 과정
1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min])을 선택
2. a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환
> 

- 비교 횟수 : (n^2 - n)/2회
- 안정적이지 않음(같은 값의 키를 가진 요소의 순서가 바뀔 수 있음)
    
    why? 서로 떨어져 있는 요소를 교환하는 것이기 때문
    

```cpp
void selection(int a[], int n){
	for(int i=0; i < n-1; i++){
		int min=i;
		for(int j=i+1; j<n; j++){
			if(a[j] < a[min) min=j;
		}
		swap(int, a[i], a[min]);
	}
} 
```

## 단순 삽입 정렬

> 단순 삽입 정렬
: 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 ‘삽입하는’ 작업을 반복하여 정렬하는 알고리즘
> 

```cpp
void insertion(int a[], int n){
	for(int i=1; i<n; i++){
		int tmp = a[i];
		int j;
		for(int j=i; j>0 && a[[j-1]>tmp; j--)
			a[j] = a[j-1];
		a[j] = tmp;
	}
}
```

<aside>
💡 **단순 정렬(버블, 선택, 삽입)의 시간 복잡도: O(n^2)**

</aside>

## 셀 정렬

> 셀 정렬
: 단순 삽입 정렬을 보완하여 더 빠르게 정렬하는 알고리즘

정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고,
그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법

’4-정렬’, ‘2-정렬’을 통해 조금이라도 정렬된 상태에 가까운 배열로 만든 후 
마지막으로 단순 삽입 정렬을 수행하여 정렬 마침
> 

```cpp
void shell(int a[], int n){
	for(int h=n/2; h>0; h/=2){
		for(int i=h; i<n; i++){
			int tmp = a[i];
			int j;
			for(j=i-h; j>=0 && a[j]>tmp; j -= h){
				a[j+h] = a[j];
			}
			a[j+h] = tmp;
		}
	}
}
```

## 퀵 정렬

> 퀵 정렬
: 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 되면 정렬을 마침



- 비벗 선택 방법
    - 나눌 배열의 요소 개수가 3 이상이면 임의로 3 요소를 선택하고 그 중에서 중앙값인 요소를 피벗으로 선택

- 시간 복잡도
    - O(nlogn)
    - 최악의 시간 복잡도: O(n^2)

## 병합 정렬

> 병합 정렬
: 배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음 병합하는 작업을 반복하여 정렬을 수행하는 알고리즘

병합
: 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업
> 

- 순서(배열의 요소 개수가 2개 이상인 경우)
    1. 배열의 앞 부분을 병합 정렬로 정렬
    2. 배열의 뒷 부분을 병합 정렬로 정렬
    3. 배열의 앞부분과 뒷부분을 병합

## 힙 정렬

> 힙 정렬
: 힙의 특성을 이용하여 정렬 수행
선택 정렬을 응용한 알고리즘

힙
: 부모의 값이 자식의 값보다 항상 크다는 조건을 만족하는 완전 이진트리
> 

- 힙 정렬) 다음 작업 반복
    - 힙에서 가장 큰 값인 루트를 꺼냄
    - 루트 이외의 부분을 힙으로 전환

- 시간 복잡도
    - 값을 한번에 선택: O(1)
    - 힙 정렬에서 다시 힙으로 만드는 작업: O(logn)

## 도수 정렬

> 도수 정렬
: 요소의 대소 관계를 판단하지 않고 빠르게 정렬할 수 있는 알고리즘

단계
1. 도수분포표 만들기
2. 누적도수분포표 만들기
3. 목적 배열 만들기
4. 배열 복사하기
> 

---

- 참고하면 좋을 링크
    
    [[알고리즘]정렬 알고리즘의 선택과 종류 7가지](https://hyo-ue4study.tistory.com/68)