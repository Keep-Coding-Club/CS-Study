# 03-1. 검색 알고리즘이란? 
## 검색의 종류
1. 배열 검색 
	- 선형 검색 
		- 무작위로 늘어놓은 데이터 집합에서 검색 수행ㅊ 
	- 이진 검색 
		- 일정한 규칙으로 늘어놓은 데이터 집합에서 아주 빠른 검색 수행 
	- 해시법
		- 추가, 삭제가 자주 일어나는 데이터 집합에서 아주 빠른 검색 수행 
		- 체인법: 같은 해시값 데이터를 연결 리스트로 연결하는 바업 
		- 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법 
2. 연결 리스트 검색 
3. 이진 검색 트리 검색 

# 03-2. 선형 검색 
## 선형 검색 
선형으로 늘어선 배열에서 검색하는 경우 원하는 키값을 가진 원소를 찾을 때 까지 맨 앞부터 스캔하여 순서대로 검색하는 알고리즘 
#### 선행 검색의 종료 조건 
1. 검색할 값을 찾지 못하고 배열의 맨 끝에 도달한 경우 - 검색 실패 
2. 검색할 값과 같은 원소를 찾은 경우 - 검색 성공 
이 조건을 반단하는 횟수는 평균 $n/2 (n: 원소의 개수)$

```python
for i in range(len(a)):
	if a[i] == key: # 종료 조건 2
		return i
return -1 # 종료 조건 1
```
원소의 값이 정렬되지 않은 배열에서 검색하는 유일한 방법 

## 보초법
선형 검색의 종료 조건 2가지를 검색하는 것도 결국 cost임 
이 cost를 줄이는 방법 
- 배열의 마지막에 검색하고자 하는 값을 삽입하여 배열의 맨 끝임을 조사할 필요가 없어짐 
- => 검색할 값과 같은 원소를 찾은 경우만 판단하면 된다 

```python
a = [1, 2, 3, 4]  
key = 10  
a.append(key) # 배열의 마지막에 key(보초)를 추가  
  
for i in range(len(a)):  
    if a[i] == key:  
        print(i if i == len(a) else -1) # i: 4, len(a): 5
```
배열의 길이를 검사하지 않아도 되기에 종료 조건을 판단하는 횟수가 절반으로 줄어든다 

# 03-3. 이진 검색 
데이터가 정렬되어 있을 때만 사용 가능 
절반씩 나누어가며 검색
## 검색 범위를 좁혀가는 과정 
- `a[i] < key` : 키가 우측에 있을 경우 -> 오른쪽을 검색한다 
- `a[i] > key` : 키가 좌측에 있을 경우 -> 왼쪽을 검색한다 

## 종료 조건 
1. `a[i] == key`
2. 검색 범위가 더 이상 없는 경우 

## 이진 탐색 코드

```python 
a = [1, 2, 3, 4, 5, 6]  
key = 1  
  
def binary_search(array, target, start, end):  
    # 인덱스 역전  
    if start > end:  
        return None  
    mid = (start + end) // 2  
    # 이진 탐색  
    if array[mid] == target:  
        return mid  
    elif array[mid] > target:  
        return binary_search(array, target, start, mid - 1)  
    else:  
        return binary_search(array, target, mid + 1, end)  
  
print(binary_search(a, key, 0, len(a)-1))
```

# 03-4. 해시법 
검색 + 데이터의 추가 삭제도 효율적으로 수행할 수 있는 방법 
만약 정렬된 배열에 특정 값을 추가한다면 아래와 같은 과정을 거쳐야 한다 
1. 검색 위치를 이진 탐색으로 찾는다 
2. 해당 위치 뒤의 원소들을 모두 한 칸씩 이동시킨다 
3. 빈 위치에 원소를 삽입한다 
이 때 원소가 이동하는데 $O(n)$ 의 시간 복잡도가 소요된다 

## 해시법 
데이터를 저장할 위치 = 인덱스를 간단한 연산으로 구하는 것 
검색뿐 아니라 추가, 삭제도 효율적으로 수행 가능 

해시 함수를 인덱스로 사용하여 값을 저장함 

## 해시 충돌 
해시 함수에 넣은 값이 중복되어 같은 위치에 다른 값이 저장되는 현상 
### 대처 방법
 1. 체인법: 해시값이 같은 원소를 연결 리스트로 관리 
 2. 오픈 주소법: 빈 버킷을 찾을 때 까지 해시를 반복 

## 체인법 
해시값이 같은 데이터를 체인 모양의 연결 리스트로 연결하는 방법 
오픈 해시법이라고도 한다 
![Pasted image 20230802204229](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/330cee76-cc35-46a9-aeff-8e7a4549227f)

## 오픈 주소법 
충돌이 발생했을 때 재해시를 수항하여 빈 버킷을 찾는 방법
