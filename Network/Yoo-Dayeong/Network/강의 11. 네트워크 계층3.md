# 강의 11. 네트워크 계층3

서브넷: 같은 IP를 갖는 집합.

NAT

디자인적인 문제점: ip 헤더, 데이터 변환으로 layer violent 발생.

현실적인 문제점: 포트번호와 ip 인터페이스를 변경하므로, 불편함 초래.

# 1. DHCP****(Dynamic Host Configuration Protocol)****

호스트 정보(IP, Mask, Router, DNS 등)를 동적으로 세팅해주는 역할

만약 DHCP가 아니라 수동으로 IP주소를 정해주게 된다면 정적으로 사전에 미리 정해줘야!

예를 들어서 A 아파트에 입주자가 10,000명이라고 할 때, 수동으로 IP를 할당하려면 10,000개를 미리 정해줘야 한다.

하지만 DHCP는 **동적으로** 사용 중인 입주자를 대상으로만 할당→ 그 수를 더 효율적으로 사용할 수 있다.

즉, 네트워크에 접속했을 때 주소가 할당되며, 이후에 회수하여 IP주소의 재사용 또한 가능해진다. (주소를 잠시 렌탈해주는 것과 같은 느낌!)

## 1-1. DHCP Discover

`사용자 : 저기.. 저 새로왔는데 아무나 저 좀 도와주세요!🙋🏻‍♂️`

현재 사용자가 내부 서버 주소도 모르고, 나의 정보도 모르는 상황이다. 아무것도 모르는 상태에서 도움을 요청하는 단계

- src
    - 현재 src가 0.0.0.0이라는 것은 사용자의 IP가 무명이라는 것이고 즉, 내가 누군지 모른다는 것이다.
- dest
    - 255.255.255.255로 모든 비트가 1로 이루어져있어 브로드캐스트하고 있음을 알 수 있다. 이 때, 서브넷에 속해있는 모든 멤버들은 브로드캐스드 받기에 이 메시지를 받을 수 있다.
- transaction ID
    - 사용자가 임의로 설정한 값이다.

이 단계에서는, DHCP 서버만 이 요청을 유의미하게 받아들이고, 나머지 멤버들은 그냥 받고 넘겨야 한다.

왜냐하면 DHCP 서버에게 도움을 요청하는 것인데, 다른 멤버가 받아서 대응하면 안되기 때문이다.

dest에 보면 포트 넘버를 67번으로 한 것을 볼 수 있는데, 즉 67번 포트를 열고 대기하고 있는 DHCP 서버가 이 메시지를 들을 수 있는 것이다.

## 1-2. DHCP Offer

`DHCP 서버 : 오케이 내가 도와줄게! 이렇게 하는건 어때?🧐`

이제 메시지를 받은 DHCP는 다시 회신을 해줘야 한다. 이에 보낸 메시지를 봐보자.

- src
    - DHCP 본인의 아이디인데, 포트넘버가 67번이기 때문에 discover에서 보냈던 메시지를 잘 받았음을 알 수 있다.
    - 그리고 이제 회신하는 메시지는 또 브로드 캐스트하여 서브넷의 모든 멤버들에게 전송되나 사용자에게만 유의미해야한다.
- dest
    - 포트 넘버가 68번인 것을 알 수 있는데, 이전에 사용자의 src를 보면 포트넘버가 68번이다.
- transaction ID
    - 654로 사용자 ID와 동일하다
- 포트 넘버와 transaction ID가 동일하기에 사용자가 유의미하게 메시지를 받아올 수 있는 것 이다.

그리고 이 offer 단계에서는, 사용자에게 "src의 아이디를 lifetime 동안 사용해라!" 라는 의미도 포함하고 있다. 말 그대로 제안하는 것이기 때문에 사용자는 판단하여 의사표현을 해야한다.

즉, 사용자는 이제 오퍼를 수락한다는 의미로 리퀘스트를 보내게 된다.

DHCP 서버가 여러 개이고, 이에 오퍼가 여러 개 올 수 있기 때문에 offer로 표현되고, 여기서 사용자가 맘에 드는 것을 선택하여 리퀘스트를 보내면 된다.

## 1-3. DHCP Request

`사용자 : 너가 준 제안으로 할게!🙋🏻‍♂️`

`다른 DHCP 서버 : 다른 서버 선택했네... ㅇㅋ😢`

- src
    - 아직까지 사용자의 IP는무명이다. 왜냐하면 아직까지 IP주소가 확정된 것이 아니기 때문이다.
- transaction ID
    - 이제 이전의 오퍼를 수락한다는 의미로 이전의 `transaction ID+1`하여 리퀘스트 보내준다.

> 이 단계에서 dest를 보면 리퀘스트도 브로드캐스트하고 있는 것을 볼 수 있다. 왜냐하면 앞서 offer 단계에서 봤듯이 DHCP 서버가 여러 개일 수 있기 때문에, 내가 선택한 서버의 정보를 보냄으로써 다른 서버는 채택되지 않음을 동시에 간접적으로 알릴 수 있다.
> 

## 1-4. DHCP ACK

`DHCP 서버 : ㅇㅋㅇㅋ`

그 이후 응답이 오면 사용자는 IP주소를 자기자신만의 것으로 사용할 수 있다. 또한 이 뿐만 아니라 라우터, DNS의 아이디도 포함되어 있어, 기본적인 네트워킹을 할 수 있도록 도와준다.

앞서 봤던 NAT나 DHCP는 실제로 어디서 쓰이고 있을까??

우리가 생활 속에서 흔히 사용하고 있는 "와이파이"가 그 예시가 될 수 있다.

예를 들어서, A통신사를 이용하여 와이파이를 사용하고 있다고 가정해보자. 그렇다면 현재 A통신사는 사용자에게 특정 IP를 하나 발급해주는 것이고 이를 통해 무선 인터넷을 사용할 수 있는 것이다. 와이파이 사용을 위해서 필요한 걸 빼먹고 말한듯하다. 바로 무선 공유기!

무선 공유기가 바로 게이트웨이 라우터의 역할을 하며 NAT, DHCP가 실행되고 있음을 알 수 있다.

예를 들어서 아까 이용하던 A통신사의 와이파이를 집에서 가족들과 함께 이용하고 있다고 해보자.

> 아빠 : 223.1.2.5
> 

이런 식으로 네트워크 IP(prefix)는 동일한데 호스트만 달라, 각자의 IP주소는 다르게 된다. 어? 그러면 내가 이용하는 IP는 하나인데 어떻게 외부로 통신할 수 있을까? 바로 여기서 IP를 할당하는 과정에서 DHCP가, 외부/내부로 통신할 때 NAT가 작동하는 것이다.

각각의 IP가 외부로 나갈 때는 라우터를 거쳐서 하나의 IP로 A통신사에 전달되는 것이다. 여기서 통신사에 전달되는 IP는 그럼 세계에서 유일한 IP일까?? 그건 확정지을 수 없다. 왜냐하면 통신사에서도 NAT를 사용할 수 있고, 그 내부에서도 NAT를 사용하고 있다면 nested programming 처럼 엄청 복잡해지게 된다. 살펴보면 IP가 같다고 해서 무조건 특정인을 지칭하는게 아니게 되는 것이다.

게임을 하다보면 IP를 추적한다느니, 그런 말을 들어보거나 본 적이 있을 것이다. 위 예시에서 동생이 게임을 하다가 악플을 써서 ip 추적을 당했다고 해서 온 가족이 그 악플을 작성한게 아니라, 그 네트워크를 이용하여 악플을 쓰기만 한 것이다. 그러니 사실 IP는 그냥 네트워크 주소일 뿐이라는 것이다. 이러한 사례만 봐도 우리는 현재 NAT의 세상에서 살고있다고 봐도 무방할 정도이다..

하지만 이러한 NAT 자체도 결함이 있는 완전한 해결법이 아니며, 그렇다고 IPv6을 도입하자니 현실적으로 어렵기에 진퇴양난의 상황인 것이다.

# 2. IP Fragmentataion/reassembly

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d97c3d90-e3ab-464a-b076-f495b559f77f/Untitled.png)

앞서 봤던 IP 헤더 필드에서 보지 않은 항목이 있다.

두 번째 행에 위치한 identifier, flags, fragment offset이다.

이 3가지 필드는 패킷을 쪼개고, 재결합하는데 필요한 정보들이다. 네트워크의 링크 레이어는 MTU(max transfer size)가 존재하는데, 이를 넘어서면 전송할 수 없게된다. 그렇다고 전송을 포기할 수 없으니 MTU에 맞게 쪼개어(fragment) 보내고, 이후에 다시 조합(reassembly)하여 사용하는 것이다.

### **identifier (ID)**

패킷의 ID는 sender가 정한다. 쪼개진 패킷들에 기존 패킷과 동일한 ID가 적히게 된다.

### **flag**

바로 내 뒤에 fragment된 패킷이 있는지 여부를 1과 0으로 표시한다.

- 1 : 내 뒤에 존재
- 0 : 없음

### **fragment offset**

쪼개진 경우 패킷이 위치하고 있는 곳을 의미한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27219fcb-ccaa-4e93-aa15-c2ab033164f3/Untitled.png)

위 사진을 보면 ID와 flag는 쉽게 이해할 수 있다. 그렇다면 offset의 숫자는 정확히 어떤 의미를 가지는 것일까?

헤더가 20바이트이기에 1500으로 나누었을 때 그 중에 헤더가 20, 데이터가 1480인 것이다. 당연히 첫 번째 조각(frame)은 offset이 0이고, 그 다음 조각은 offset이 185이다.

> 1480 / 8 = 185
> 

왜 8로 나누었냐하면, 8로 나누었을 때 3비트 시프트하여 비트 수가 줄어드는 효과를 볼 수 있기 때문이다.

그리고 그 다음 조각은 (1480 + 1480) / 8 하여 370이 나오게 되는 것이다. 연산 시에, 헤더를 잘 고려해주기만 한다면 무리없이 알맞는 수를 구해낼 수 있다.