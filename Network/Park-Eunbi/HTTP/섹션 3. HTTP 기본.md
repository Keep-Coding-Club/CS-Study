# 모든 것이 HTTP
거의 모든 형태의 데이터를 HTTP로 전송 
서버간 데이터를 주고 받을 때도 대부분 HTTP 사용 

## HTTP 특징
클라이언트 서버 구조
무상태 프로토콜 (스테이스리스), qldusruftjd 
HTTP 메시지
단순함, 확장 가능 

# 클라이언트 서버 구조 
Request Response 구조 
클라이언트는 서버에 요청을 보내고, 응답을 대기 
서버가 요청에 대한 결과를 만들어 응답
- 클라이언트는 서버의 구조를 알 필요가 없다 

# 무상태 프로토콜
stateless
- 서버가 클라이언트의 상태 보존 x
- 장점: 서버 확장성이 높음 (스케일 아웃)
- 단점: 클라이언트가 추가 데이터 전

## Stateful, Stateless 차이 
### 상태 유지 - stateful
- 상황, 문맥을 유지하는 것 

### 무상태 - stateless
- 상황, 문맥을 유지하지 않는 것 

### 정리 
상태 유지
	중간에 다른 점원으로 바뀌면 안된다 
	점원이 바뀌면 상태 정보를 다른 점원에게 미리 알려줘야 한다 
	항상 같은 서버가 유지되어야 한다 
무상태 
	중간에 다른 점원으로 바뀌어도 된다 
		갑자기 고객이 증가해도 점원을 대거 투입할 수 있다 
		갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다 
		- 상태를 유지하지 않아 매 번 정보를 가지고 있기 떄문에 가능 
	무상태는 응답 서버를 쉽게 바꿀 수 있다 -> 무한한 서버 증설 가능 

## Stateless 실무 한계 
모든 것을 무상태로 설계할 수 있을 수도 없을 수도 있다 
무상태 
	로그인이 필요 없는 단순한 서비스 소개 화면 
상태 유지 
	로그인 
로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지 
일반적으로 브라우저 쿠키와 서버 세션들을 사용하여 상태 유지 
상태 유지는 최소한만 사용 

# 비연결성 (connectionless)
- 연결을 유지한다면 데이터를 주고 받지 않더라도 연결을 항상 유지해야 한다 
	- 자원 낭비
HTTP는 기본이 연결을 유지하지 않는 모델 
일반적으로 초 단위 이하의 빠른 속도로 응답 
1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다 
서버 자원을 매우 효율적으로 사용할 수 있다 

## 한계와 극복 
TCP/IP 연결을 새로 맺어야 한다 - 3 way handshake 시간 추가 
웹 브라우저로 사이트를 요청하면 HTML, JS, CSS, IMG 등 수 많은 자원이 함께 다운로드 된다
지금은 HTTP 지속 연결로 문제 해결 

## 스테이스리스를 기억하자 
서버 개발자들이 어려워하는 업무 
정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽 
	선착순 이벤트, 명절 KTX, 학과 수업 등록 
	-> 수만명 동시 요청 

# HTTP 메시지 
![[Pasted image 20230728125654.png]]

## 단순함 확장 가능 
HTTP는 단순하다
HTP 메시지도 단순하다 

## 정리 
HTTP 메시지에 모든 것을 전송 
HTTP/1.1을 기준으로 학습 
클라이언트 - 서버 구조 
무상태 프로토콜 (stateless)
HTTP 메시지 
단순함, 확장 가능 
지금은 HTTP의 시대 