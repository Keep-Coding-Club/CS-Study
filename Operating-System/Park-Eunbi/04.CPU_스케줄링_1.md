# 01. 스케줄링의 개념 
## 스케줄링 
시스템의 목표를 달성할 수 있도록 프로세서를 할당하는 일련의 과정 
- 프로세서의 이용률을 높이고 
- 시스템의 작업 처리 능력을 향상 
- 작업의 응답시간 최소화 
## 프로세스 스케줄링과 프로세스 스케줄러
다중 프로그래밍의 목적 
- cpu의 이용률을 높이기 위해 
- 항상 임의의 프로세스를 실행할 수 있도록 함 
시분할 시스템의 목적 
- 프로그램이 수행되는 동안 사용자가 각 프로그램과 상호작용 할 수 있도록 
- cpu가 프로세스들 사이를 빠르게 전환하며 수행 
=>
프로세스 스케줄러 (process/cpu scheduler)
- 프로세스들 중에 수행 가능한 한 프로세스를 선택 
## 스케줄링 기본 요소 (1): 프로세스 실행 
스케줄링 여부 
- 스케줄링 하지 않고 실행하는 것 
	- 인터럽트/오류 처리, 사용자의 시스템 호출 등의 사전 처리 
- 스케줄링 해야 하는 것 
	- 사용자/시스템 프로세스 
실행(프로세스 버스트)과 입출력 대기 (입출력 버스트)의 순환으로 구성 
- 프로세스들은 이 두상태 사이에서 교대로 진행 
## 스케줄링 기본 요소 (2): 프로세서 버스트 
프로세서 버스트 지속시간은 일반적으로 지수 성질의 빈도 곡선으로 표현됨
- 프로세서 중심의 프로그램은 긴 cpu 버스트를 가짐 
- 입출력 중심의 프로그램은 짧은 cpu 버스트를 가짐 
## 스케줄링 단계 
![Pasted image 20230830224132](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/6a060619-0a60-4bea-bd2d-49849bd5de02)
## 스케줄링 시 고려사항 
자원 할당의 공정성 
단위 시간당 처리량 향상 
적절한 응답시간 유지 
예측 가능성
- 시스템 부하에 무관하게 거의 같은 시간 내에 비슷한 비용으로 실행 가능해야 함 
일반적으로 과부하는 줄여야 
자원 사용 
- 가능한 사용율을 높일 수 있도록 스케줄링 
응답시간과 자원의 활용 간의 균형 유지 
- 응답 시간을 줄이기 위해선 충분한 자원 확보 필요 
	- 자원 활용도를 낮추게 되는 원인이 되기도 
실행 대기 
- 실행이 연기되는 것을 피해야. 에이징 방법 
프로세스의 우선순위 
서비스 사용 기회 
서비스 수 
- 갑작스런 서비스 수 감소 방지 필요 
- 과부하에 대처 
# 02. cpu 스케줄링 큐와 스케줄러 
## 프로세스 스케줄링 큐
![Pasted image 20230830224927](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/b0b4cf66-8ddd-4e9c-b22d-ad99e6ae52d7)
## 각 스케줄러의 실행 빈도
단기 스케줄러는 매우 자주 호출됨 
장기 스케줄러는 덜 자주 호춫됨 
- 수 초~분 마다 
- 일괄 처리 시스템에서 다중 프로그래밍 정도 (degree of multiprogramming)를 제어 
	- 시분할 시스템엔 필요하지 않음 
	- 사용자가 스스로 다중 프로그래밍 정도를 조정 
## 프로세스 특징에 따른 장기 스케줄링 
입출력 중심 프로세스 (I/O  bound process)
- cpu의 연산보다 io 수행에 더 많은 시간 소모 
- cpu를 짧은 시간 동안만 사용 
cpu 중심 프로세스 (cpu bound process)
- io 수행보다 cpu 연산에 더 많은 시간 소모 
- cpu를 오랫동안 사용해야 함 
=> 장기 스케줄러는 위 프로세스들을 적절히 혼합하여 선택해야 효율적 
## 중기 스케줄러 
스와핑(swapping)
- 시분할 시스템에서 주기억장치에서 프로세스들을 임시로 제거하여 다중 프로그래밍 정도를 완화시키거나 
- 프로세스들의 혼합성 개선을 위해 
## 단기 스케줄러
디스패처(dispatcher)
- 선택한 프로세스에 실질적으로 프로세서를 할당 
- 프로세스의 레지스터 적재(context switching)
- 사용자 상태로 전환 
## 스케줄링과 프로세스 상태 변환 
![Pasted image 20230830230205](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/43572fc6-591c-4484-a15f-7faeca8ce976)
## 선점형 vs 비선점형 
비선점형 
- 프로세스가 스스로 cpu를 반납 (비강제적)
선점형 
- 강제적으로 cpu 할당을 받음 
- 공유 자료에 대한 접근 조정 필요 
- 컨텍스트 전환 전에 시스템 호출 처리를 완료하거나 io 요청을 blocking 함 
	- 실시간 컴퓨팅이나 멀티 프로세서 지원에 악영향
## cpu 스케줄링 알고리즘 비교 기준
cpu 이용률(Utilization) 높은 것
- 가능한 cpu를 busy 하게 유지 (40~90%)
처리율(Throughput) 높은 것
- 단위 시간 동안 완료된 프로세스들의 개수 
총 처리 시간(Turnaround time)
- 한 프로세스를 처리하는 데 걸린 시간 
- cpu + io + waiting + ready
대기시간 (waiting time) 적은 것 
- 프로세스가 ready 큐에서 대기한 시간 
- 스케줄링 알고리즘에 따르 크게 차이남
응답 시간 (response time) 작은 것 
- 요청 후 첫 응답(!= 출력)이 나오는 데까지 걸린 시간 
- 평균 응답 시간의 최소보다는 응답 시간 사이의 변동 폭 최소가 중요하기도
