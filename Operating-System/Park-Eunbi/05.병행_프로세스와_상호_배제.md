# 01. 병행 프로세스와 상호배제
## 병행 프로세스 (concurrent process)
프로세스 여러 개가 동시에 실행 되는 것 
- 독립적으로 작업을 수행하거나 다른 프로세스와 협력 하며 수행 
- 제한된 자원을 공유하기 위해 자주 상호작용함 
	- 상호작용하는 프로세스는 순서에 맞게 실행되도록 동기화 시켜야 함 
- 병행성 (= 동시성)
	- 다수의 프로세스를 이용해 작업을 수행 
	- 다중 프로세싱 시스템, 분산처리 환경, 다중 프로그래밍 -> os에서 중요한 이슈 
	- 시스템의 신리도 향상과 처리 속도 개선을 통한 처리 능력 증대에 매우 중요 

cf) 병렬성: 서로 다른 프로세스들이 동시에 작업 
병행성: 하나의 프로세서 안에서 여러 프로세스가 돌아감 
## 병행 프로세스의 과제 
공유 자원을 상호 배타적으로 사용해야 함 
협력 또는 동기화 필요 
데이터 교환을 위한 통신 필요 
결정성 (deterinacy) 확보
- 다른 프로세스들의 실행 속도와 관계없이 일정한 실행 결과 보장 필요 
교착 상태를 해결하고 병렬 처리 능력 극대화 필요 
실행 검증 문제가 해결되어야 함 
상호배제 보장 
- 하나가 작업 중일 때 다른 것은 작업을 수행하지 못하게 하는 것 
## 프로세스 간 통신 (IPC)
### 병행 프로세스 
독립적인 프로세스 (independent process)
- 다른 프로세스 실행에 영향을 주거나 받지 않는 프로세스 
협력적인 프로세스 (cooperating process)
- 다른 프로세스 실행에 영향을 주거나 받는 프로세스 
	- 정보 계산 
	- 계산 속도 향상 
	- 모듈식 시스템 구성 
	- 사용자 편의 
협동 프로세스 간에는 통신 기법 필요 
- 기본적으로 프로세스는 자신에게 할당된 메모리에만 접근이 가능 
- 방법
	- 공유 메모리 (shared memory)
		- 직접 공유 
		- 빠른 속도와 편의성 제공 
		- 접근은 쉽지만 만들기 어려움 
		- 대량의 자료 
	- 메시지 전달 
		- 커널의 중개 (message passing) - 운영체제에게 맡김
		- 적은 양의 자료 교환에 유용 
![Pasted image 20230905171042](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/c03b867f-4e7b-4c61-9a66-62e9dfa8d46b)
    

## 공유 메모리 시스템 
서로 통신하려는 프로세스 간에 공유 메모리 영역을 구축 
- 각 프로세스는 이 영역을 자신의 주소 공간에 추가하고 접근 
접근 방법 
- 공유 메모리에 기록되는 자료의 형식이나 위치는 프로세스들에 의해 결정 
	- os 소관 아님 
- 동시에 동일한 위치에 쓰지 않도록 해야 함 
	- 동기화 등의 문제 발생 
## 신호 (signal)
한 프로세스에게 어떤 상황의 발생을 비동기적으로 알리는 방법 
- 한 프로세스가 다른 프로세스에게 비동기 상황이 발생함을 알림 
- 커널이 특정 프로세스에게 
현재 프로세스 내/외부에서 예상치 못하게 발생하는 비동기적 사건을 처리하기 위한 방법
- 신호의 전달은 커널에 의해 이뤄짐 
가장 오래된 ipc 방법
## 파이프 
프로세스 간에 데이터를 전달하는 방법 
- 전송되는 데이터의 읽기/쓰기 위치를 임의로 변경할 수 없고
- 순차적으로 읽고 써야 함 
- 시스템 호출을 통해 커널 공간에 생성된 파이프를 통해 전달 

# 02. 생산자 소비자 문제 
## 배경 
협동 프로세스들 간에 
- 공유 데이터를 동시에 조작하면 데이터 불일치가 생길 수 있음 
데이터 일치를 위해서는 
- 협동 프로세스들을 순서적으로 실행하는 방법이 필요 
## 생산자 - 소비사 문제 
협동 프로세스의 일반적인 패러다임 
- 생산자 프로세스: 정보를 생산
- 소비자 프로세스: 정보를 소비 
생산자와 소비자가 정보를 주고 받으며 병행 실행하기 위해서는 
- producer, comsumer가 공유하는 메모리에 버퍼를 두고 이를 통해 정보 전달 
- producer 와 consumer는 동기화되어야 함 
- 동기화 <- **순서에 맞추어** 라고 생각하면 된다 
## 버퍼의 두 유형 
무한 버퍼 
- 버퍼의 크기에 한계가 없다 
- porducer는 항상 새 항목 생산 가능
-  consumer 는 버퍼가 empty이면 대기 
유한 버퍼
- 버퍼의 크기가 고정되어 있다
- producer는 버퍼가 full이면 대기 
- consumer는 버퍼가 empty이면 대기 
## 유한 버퍼의 개선 
공유 메모리 시스템 
- 생산자 소비자 문제 
- 최대 buffer-size -1 개 요소만 저장 가능 
버퍼 전체를 사요하기 위한 개선안 
- 버퍼의 유효 크기를 변수에 저장 
	- int counter = 0
	- 버퍼에 항목 추가시: counter++;
	- 버퍼에 항목 제거시: counter--;
# 03. 경쟁 상태
## 원자적 동작 
수행 중 중지(interruption) 되지 않고 전체가 수행될 수 있는 연산 
두 프로세스 간에 동시에 접근될 수 있는 공유 변수 counter 는 원자적(atomically)으로 수행되어야 함 
- producer: counter++;
- consumer: counter--;
## 유한 버퍼의 문제 
producer와 consumer가 동시에 공유 변수를 갱신하는 경우 
- 공유 변수 변경ㅇ르 위한 각각의 기계어는 interleaving될 수 있음 
interleaving은 producer와 consumer가 어떻게 스케줄 되는지에 따라 달라짐 
## 경쟁 상태 (race condition)
몇몇 프로세스들이 공유 데이터를 동시에 (concurrenlty) 접근하는 상황 
데이터의 결과를 보장할 수 없는 상황 
- 공유 데이터의 최종값은 마지막으로 접근한 프로세스에 의존 
- 앞서 접근한 프로세스의 영향은 무시됨 
경쟁 상태를 방지하기 위해서는 
- 협동 프로세스들은 동기화(synchronized) 되어야 함 
# 04. 임계영역 문제 
## 임계영역 문제 (critical secion problem)
공유 데이터를 사용하기 위해 경쟁하는 n 개의 프로세스들 가정 
- 임계영역 
	- 각 프로세스에서 공유 데이터를 조작하는 명령을 포함하는 코드 영역을 가리킴 
	- 공유 데이터는 둘 이상의 프로세스가 동시에 접근하면 안됨 
한 프로세스가 임계 영역을 수행 중이면 
- 다른 프로세스는 자신의 임계 영역의 코드를 수행할 수 없어야 함 
- - > 한 번에 한 프로세스만 공유 데이터에 접근 할 수 있도록 
## 프로세스 $p_i$ 의 일반적인 구조 
진입 영역 
- 임계 영역으로 진입 허가 요청 코드 
출구 영역 
- 임계 영역 탈출시 권한 반납 코드 
## 임계 영역 문제의 해결책 
다음 세 가지 요구 조건을 충족해야 함 
- 진입 상호 배제 (mutual exclusion)
- 진행 (progress)
- 한계 대기 (bounded waiting)
## 상호 배제 (mutual exclusion)
=> 누군가 사용중일 때 
- 프로세스 $p_i$가 임계 영역에서 실행된다면 
- 다른 프로세스들은 임계 영역에서 실행될 수 없다 
- -> 한 번에 하났기 
## 진행 (progress)
=> 비어 있어 사용가능할 때 
- 임계 영역에서 실행되는 프로세스가 없는 상태에서 임계 영역으로 진입하려고 하는 프로세스들이 있다면 
- 잔류 영역에서 실행되지 않고 있는 프로세스들만 다음에 임계 영역으로 진입할 수 있는 대상이 되며, 이 선택은 무한하게 연기 될 수 없다 
=> 임계 영역 바깥에 있는 프로세스가 다른 프로세스의 임계 영역 진입을 막으면 안됨
## 한계 대기 (bounded waiting)
임의의 프로세스가 자신의 임계 영역에 진입 요청을 한 후 허가되기 전 가지 
다른 프로세스들이 자신의 임계 영역에 진입하는 회수에슨 한계가 있어야 한다 
=> 어떤 프로세스도 임계 영역에 들어가는 것이 연기되어서는 안됨 
- 기아상태/교착 상태가 발생하면 안됨 
