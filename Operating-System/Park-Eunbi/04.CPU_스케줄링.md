# 01. 스케줄링의 개념 
## 스케줄링 
시스템의 목표를 달성할 수 있도록 프로세서를 할당하는 일련의 과정 
- 프로세서의 이용률을 높이고 
- 시스템의 작업 처리 능력을 향상 
- 작업의 응답시간 최소화 
## 프로세스 스케줄링과 프로세스 스케줄러
다중 프로그래밍의 목적 
- cpu의 이용률을 높이기 위해 
- 항상 임의의 프로세스를 실행할 수 있도록 함 
시분할 시스템의 목적 
- 프로그램이 수행되는 동안 사용자가 각 프로그램과 상호작용 할 수 있도록 
- cpu가 프로세스들 사이를 빠르게 전환하며 수행 
=>
프로세스 스케줄러 (process/cpu scheduler)
- 프로세스들 중에 수행 가능한 한 프로세스를 선택 
## 스케줄링 기본 요소 (1): 프로세스 실행 
스케줄링 여부 
- 스케줄링 하지 않고 실행하는 것 
	- 인터럽트/오류 처리, 사용자의 시스템 호출 등의 사전 처리 
- 스케줄링 해야 하는 것 
	- 사용자/시스템 프로세스 
실행(프로세스 버스트)과 입출력 대기 (입출력 버스트)의 순환으로 구성 
- 프로세스들은 이 두상태 사이에서 교대로 진행 
## 스케줄링 기본 요소 (2): 프로세서 버스트 
프로세서 버스트 지속시간은 일반적으로 지수 성질의 빈도 곡선으로 표현됨
- 프로세서 중심의 프로그램은 긴 cpu 버스트를 가짐 
- 입출력 중심의 프로그램은 짧은 cpu 버스트를 가짐 
## 스케줄링 단계 
![Pasted image 20230830224132](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/6a060619-0a60-4bea-bd2d-49849bd5de02)
## 스케줄링 시 고려사항 
자원 할당의 공정성 
단위 시간당 처리량 향상 
적절한 응답시간 유지 
예측 가능성
- 시스템 부하에 무관하게 거의 같은 시간 내에 비슷한 비용으로 실행 가능해야 함 
일반적으로 과부하는 줄여야 
자원 사용 
- 가능한 사용율을 높일 수 있도록 스케줄링 
응답시간과 자원의 활용 간의 균형 유지 
- 응답 시간을 줄이기 위해선 충분한 자원 확보 필요 
	- 자원 활용도를 낮추게 되는 원인이 되기도 
실행 대기 
- 실행이 연기되는 것을 피해야. 에이징 방법 
프로세스의 우선순위 
서비스 사용 기회 
서비스 수 
- 갑작스런 서비스 수 감소 방지 필요 
- 과부하에 대처 
# 02. cpu 스케줄링 큐와 스케줄러 
## 프로세스 스케줄링 큐
![Pasted image 20230830224927](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/b0b4cf66-8ddd-4e9c-b22d-ad99e6ae52d7)
## 각 스케줄러의 실행 빈도
단기 스케줄러는 매우 자주 호출됨 
장기 스케줄러는 덜 자주 호춫됨 
- 수 초~분 마다 
- 일괄 처리 시스템에서 다중 프로그래밍 정도 (degree of multiprogramming)를 제어 
	- 시분할 시스템엔 필요하지 않음 
	- 사용자가 스스로 다중 프로그래밍 정도를 조정 
## 프로세스 특징에 따른 장기 스케줄링 
입출력 중심 프로세스 (I/O  bound process)
- cpu의 연산보다 io 수행에 더 많은 시간 소모 
- cpu를 짧은 시간 동안만 사용 
cpu 중심 프로세스 (cpu bound process)
- io 수행보다 cpu 연산에 더 많은 시간 소모 
- cpu를 오랫동안 사용해야 함 
=> 장기 스케줄러는 위 프로세스들을 적절히 혼합하여 선택해야 효율적 
## 중기 스케줄러 
스와핑(swapping)
- 시분할 시스템에서 주기억장치에서 프로세스들을 임시로 제거하여 다중 프로그래밍 정도를 완화시키거나 
- 프로세스들의 혼합성 개선을 위해 
## 단기 스케줄러
디스패처(dispatcher)
- 선택한 프로세스에 실질적으로 프로세서를 할당 
- 프로세스의 레지스터 적재(context switching)
- 사용자 상태로 전환 
## 스케줄링과 프로세스 상태 변환 
![Pasted image 20230830230205](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/43572fc6-591c-4484-a15f-7faeca8ce976)
## 선점형 vs 비선점형 
비선점형 
- 프로세스가 스스로 cpu를 반납 (비강제적)
선점형 
- 강제적으로 cpu 할당을 받음 
- 공유 자료에 대한 접근 조정 필요 
- 컨텍스트 전환 전에 시스템 호출 처리를 완료하거나 io 요청을 blocking 함 
	- 실시간 컴퓨팅이나 멀티 프로세서 지원에 악영향
## cpu 스케줄링 알고리즘 비교 기준
cpu 이용률(Utilization) 높은 것
- 가능한 cpu를 busy 하게 유지 (40~90%)
처리율(Throughput) 높은 것
- 단위 시간 동안 완료된 프로세스들의 개수 
총 처리 시간(Turnaround time)
- 한 프로세스를 처리하는 데 걸린 시간 
- cpu + io + waiting + ready
대기시간 (waiting time) 적은 것 
- 프로세스가 ready 큐에서 대기한 시간 
- 스케줄링 알고리즘에 따르 크게 차이남
응답 시간 (response time) 작은 것 
- 요청 후 첫 응답(!= 출력)이 나오는 데까지 걸린 시간 
- 평균 응답 시간의 최소보다는 응답 시간 사이의 변동 폭 최소가 중요하기도

# 03. FCFS
선입 선처리 스케룰링 
First-come, First-Served 
- cpu를 먼저 요청하는 프로세스가 cpu를 먼저 할당 받음
	- 비선점형 (cpu를 강제로 빼앗을 수 없음)
- 가장 간단한 알고리즘 
- ready 큐 (cpu 사용 대기 큐)를 fifio 큐로 쉽게 구현 
- 평균 대기 시간이 길어질 수 있음 
![Pasted image 20230905142718](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/d71837c2-1377-4824-9d81-e75817e65afc)   

## 회위 효과 (convoy effect)
긴 cpu bust 를 가진 프로세스가 cpu가 할당 되기를 다른 프로세스들이 기다림 
cpu와 io장치들은 idle 시간이 커짐 
-> 빨리 끝날 수 있는 프로세스부터 처리해보자 
- shortest job first scheduling
# 04. SJF
최소 작업 우선 스케줄링 
shortest job first scheduling 
- shortest next cpu burst scheduling 
	- 다음에 수행할 프로세스 들 중 가장 짧은 cpu burst 를 갖는 프로세스를 우선 선택 
	- 동일한 수행 시간을 갖는다면 fcfs로 처리 
- 특징 
	- 평균 대기시간이 가장 작음 (최적)
	- 다음 cpu brust 의 길이 파악이 어려움
		- 현실적으로 cpu를 얼마나 사용할지 알 수 없음 
		- 이전 사용량을 토대로 계산 (지수 평균 방법 사용)
 
![Pasted image 20230905144314](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/d3f8da71-7b41-4a20-ace4-9f3be07248a9) 
       

# 05. SRTF
최소 잔여시간 우선 스케줄링 
shortest reamining time first scheduling 
- 선점형 SJF
	- ready 큐에 현재 실행중인 프로세스 A의 잔여 CPU burst 보다 
	- 더 짧은 cpu burst 를 가진 프로세스 B가 ready 큐에 도착하면 
	- A는 B에게 선점됨 
![Pasted image 20230905144246](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/a8d065b3-b7a6-4c9d-abcf-47840863f476)   

# 06. 우선순위 스케줄링
priority scheduling 
- 각 프로세스에 우선 순위 지정 
- 가장 높은 우선순위를 가진 프로세스에게 cpu 할당 
	- 선점형, 비선점형 모두 가능 
- 기준 
	- 내부/외부적 요인들 
	- FCFS: ready 큐에 들어온 순서 
	- SJF : (추정된) cpu burst 의 길이 
	- SRTF: (추정된) 잔여 cpu brust 의 길이 
  
- 기아 (starvation) / 무한 봉쇄 (ubdefubute blocking)
	- 낮은 우선순위의 프로세스들이 무한히 대기 
		- 실행 준비는 되어 있으나 cpu를 할당 받지 못함 
- 해결책: 에이징(aging)
	- 오래도록 처리되지 못하고 남아있는 프로세스에 대해 점진적으로 우선순위를 올려주는 기법    

![Pasted image 20230905145224](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/46df5088-e770-4c10-8c45-3eb2283d9685)     
# 07. RR 
순환 할당 스케줄링 
round robin scheduling 
- 시분할 시스템을 위해 설계됨 
- 비선점형 불가 
- 규정 시간량 (time quantum) / 시간 할당량 (time slice)
	- 각 프로세스에게 한 번에 할당되는 cpu 시간 
	- 이 시간이 만료되어 설정된 타이머에서 완료 인터럽트 발생시 디스패치 
- 선점형 fcfs
	- FCFS와 유사하나 프로세스들 사이를 강제로 옮기기 위한 선점이 추가 
	- 순환 fifo ready 큐
- 일반적으로 평균 대기 시간이 길다 
	- 사용자 응답성을 고려한 스케줄링

![Pasted image 20230905150507](https://github.com/Keep-Coding-Club/CS-Study/assets/87464975/63d12486-9558-47c2-ba44-c80402ace29d)
   
## RR 의 성능 
- 시간 할당량의 크기와 성능 
	- infinite : fcfs와 유사 
- too short: 프로세서 공유와 유사 
	- n 개의 프로세스는 각각 1/n 속도로 실행된느 자신만의 프로세스를 가지고 있는 것 처럼 보여짐 
=> 시간 할당량은 컨텍스트 전환 시간 보다 어느 정도는 충분히 커야 한다 
- 시간 할당량 크기에 비례해서 항상 개선되지는 않음 
- 대부분의 프로세스가 시간 할당량 안에 다음 cpu burst를 끝낸다면 개선 
	- 보통 cpu brust의 80%는 규정 시간량 보다 짧아야 한다 
# 08. 다단계 큐 스케줄링 
- 프로세스들이 쉽게 상이한 그룹으로 분류될 수 있는 경우에 유용 
	- foreground (interactive)
	- background (batch)
- ready 큐를 다수의 독립적인 큐로 분류하여 구성 
	- 각 프로세스는 특성에 따라 영구적으로 특정 큐에 할당 
	- 각 큐는 자신만의 스케줄링 알고리즘을 가지고 프로세스들을 스케줄
- fixed priority preemprive 스케줄링으로 구현 
	- 각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가짐 
		- 기아 상태 발생 가능 
- 큐 사이에 규정 시간량을 할당 
	- 각 큐는 cpu 시간의 일정량을 받아 자신에게 속해 있는 프로세스들을 스케줄 
## 다단계 피드백 큐 스케줄링 
큐 사이에 프로세스들의 이동을 허용 
- cpu 시간을 많이 사용하는 프로세스는 lower priority 큐로 이동 
- lower priority 큐에서 너무 오래 대기하는 프로세스는 higher priority 큐로 이동 
가장 일반적인 cpu 스케줄링 알고리즘 
성능에 영향을 미치는 매개변수들이 많기에 복잡
- 큐 개수 
- 각 큐의 스케줄링 알고리즘 
- 프로세스의 큐 이동 시기 결정 방법
- 프로세스 생성시 진입할 큐 결정 방법
# 09. HRN 
highest response rate next cheduling 
- SJR 기법의 단점이 긴 작업과 짧은 작업 간의 지나친 불평등을 어느 정도 보완한 기법 
	- 비선점형 스케줄링 기법 
		- 한 작업이 프로세스르 차지하면 종료될 때 까지 실행 
	- 가변적 우선순위 
		- 우선 순위 = $\frac{대기한 시간 + 서비스를 받을 시간}{서비스를 받을 시간}$
	- 시스템의 응답 시간 = 대기한 시간 + 서비스 받을 시간 
